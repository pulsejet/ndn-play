declare namespace t {
/// <reference types="node" />
/**
 * Use this symbol to delete properies in deepObjectAssign.
 */
export const DELETE: unique symbol;
/**
 * Turns `undefined` into `undefined | typeof DELETE` and makes everything
 * partial. Intended to be used with `deepObjectAssign`.
 */
export type Assignable<T> = T extends undefined ? (T extends Function ? T : T extends object ? {
    [Key in keyof T]?: Assignable<T[Key]> | undefined;
} : T) | typeof DELETE : T extends Function ? T | undefined : T extends object ? {
    [Key in keyof T]?: Assignable<T[Key]> | undefined;
} : T | undefined;

/** Queue configuration object. */
interface QueueOptions {
    /** The queue will be flushed automatically after an inactivity of this delay in milliseconds. By default there is no automatic flushing (`null`). */
    delay?: null | number;
    /** When the queue exceeds the given maximum number of entries, the queue is flushed automatically. Default value is `Infinity`. */
    max?: number;
}
/**
 * Queue extending options.
 *
 * @typeParam T - The type of method names to be replaced by queued versions.
 */
interface QueueExtendOptions<T> {
    /** A list with method names of the methods on the object to be replaced with queued ones. */
    replace: T[];
    /** When provided, the queue will be flushed automatically after an inactivity of this delay in milliseconds. Default value is null. */
    delay?: number;
    /** When the queue exceeds the given maximum number of entries, the queue is flushed automatically. Default value of max is Infinity. */
    max?: number;
}
/**
 * Queue call entry.
 * - A function to be executed.
 * - An object with function, args, context (like function.bind(context, ...args)).
 */
export type QueueCallEntry = Function | {
    fn: Function;
    args: unknown[];
} | {
    fn: Function;
    args: unknown[];
    context: unknown;
};
/**
 * A queue.
 *
 * @typeParam T - The type of method names to be replaced by queued versions.
 */
export class Queue<T = never> {
    /** Delay in milliseconds. If defined the queue will be periodically flushed. */
    delay: null | number;
    /** Maximum number of entries in the queue before it will be flushed. */
    max: number;
    private readonly _queue;
    private _timeout;
    private _extended;
    /**
     * Construct a new Queue.
     *
     * @param options - Queue configuration.
     */
    constructor(options?: QueueOptions);
    /**
     * Update the configuration of the queue.
     *
     * @param options - Queue configuration.
     */
    setOptions(options?: QueueOptions): void;
    /**
     * Extend an object with queuing functionality.
     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
     *
     * @param object - The object to be extended.
     * @param options - Additional options.
     *
     * @returns The created queue.
     */
    static extend<O extends {
        flush?: () => void;
    }, K extends string>(object: O, options: QueueExtendOptions<K>): Queue<O>;
    /**
     * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
     */
    destroy(): void;
    /**
     * Replace a method on an object with a queued version.
     *
     * @param object - Object having the method.
     * @param method - The method name.
     */
    replace<M extends string>(object: Record<M, () => void>, method: M): void;
    /**
     * Queue a call.
     *
     * @param entry - The function or entry to be queued.
     */
    queue(entry: QueueCallEntry): void;
    /**
     * Check whether the queue needs to be flushed.
     */
    private _flushIfNeeded;
    /**
     * Flush all queued calls
     */
    flush(): void;
}

/**
 * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */
export abstract class DataSetPart<Item, IdProp extends string> implements Pick<DataInterface<Item, IdProp>, "on" | "off"> {
    private readonly _subscribers;
    protected _trigger(event: "add", payload: EventPayloads<Item, IdProp>["add"], senderId?: Id | null): void;
    protected _trigger(event: "update", payload: EventPayloads<Item, IdProp>["update"], senderId?: Id | null): void;
    protected _trigger(event: "remove", payload: EventPayloads<Item, IdProp>["remove"], senderId?: Id | null): void;
    /** @inheritDoc */
    on(event: "*", callback: EventCallbacksWithAny<Item, IdProp>["*"]): void;
    /** @inheritDoc */
    on(event: "add", callback: EventCallbacksWithAny<Item, IdProp>["add"]): void;
    /** @inheritDoc */
    on(event: "remove", callback: EventCallbacksWithAny<Item, IdProp>["remove"]): void;
    /** @inheritDoc */
    on(event: "update", callback: EventCallbacksWithAny<Item, IdProp>["update"]): void;
    /** @inheritDoc */
    off(event: "*", callback: EventCallbacksWithAny<Item, IdProp>["*"]): void;
    /** @inheritDoc */
    off(event: "add", callback: EventCallbacksWithAny<Item, IdProp>["add"]): void;
    /** @inheritDoc */
    off(event: "remove", callback: EventCallbacksWithAny<Item, IdProp>["remove"]): void;
    /** @inheritDoc */
    off(event: "update", callback: EventCallbacksWithAny<Item, IdProp>["update"]): void;
    /**
     * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
     */
    subscribe: DataSetPart<Item, IdProp>["on"];
    /**
     * @deprecated Use off instead (PS: DataView.unsubscribe === DataView.off).
     */
    unsubscribe: DataSetPart<Item, IdProp>["off"];
    get testLeakSubscribers(): any;
}

/**
 * Data stream
 *
 * @remarks
 * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].
 * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.
 * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).
 *
 * @typeParam Item - The item type this stream is going to work with.
 */
export class DataStream<Item> implements Iterable<[Id, Item]> {
    private readonly _pairs;
    /**
     * Create a new data stream.
     *
     * @param pairs - The id, item pairs.
     */
    constructor(pairs: Iterable<[Id, Item]>);
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */
    [Symbol.iterator](): IterableIterator<[Id, Item]>;
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */
    entries(): IterableIterator<[Id, Item]>;
    /**
     * Return an iterable of keys in the stream.
     */
    keys(): IterableIterator<Id>;
    /**
     * Return an iterable of values in the stream.
     */
    values(): IterableIterator<Item>;
    /**
     * Return an array containing all the ids in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     *
     * @returns The array with all ids from this stream.
     */
    toIdArray(): Id[];
    /**
     * Return an array containing all the items in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     *
     * @returns The array with all items from this stream.
     */
    toItemArray(): Item[];
    /**
     * Return an array containing all the entries in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     *
     * @returns The array with all entries from this stream.
     */
    toEntryArray(): [Id, Item][];
    /**
     * Return an object map containing all the items in this stream accessible by ids.
     *
     * @remarks
     * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
     *
     * @returns The object map of all id → item pairs from this stream.
     */
    toObjectMap(): Record<Id, Item>;
    /**
     * Return a map containing all the items in this stream accessible by ids.
     *
     * @returns The map of all id → item pairs from this stream.
     */
    toMap(): Map<Id, Item>;
    /**
     * Return a set containing all the (unique) ids in this stream.
     *
     * @returns The set of all ids from this stream.
     */
    toIdSet(): Set<Id>;
    /**
     * Return a set containing all the (unique) items in this stream.
     *
     * @returns The set of all items from this stream.
     */
    toItemSet(): Set<Item>;
    /**
     * Cache the items from this stream.
     *
     * @remarks
     * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
     * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
     *
     * ## Example
     * ```javascript
     * const ds = new DataSet([…])
     *
     * const cachedStream = ds.stream()
     *   .filter(…)
     *   .sort(…)
     *   .map(…)
     *   .cached(…) // Data are fetched, processed and cached here.
     *
     * ds.clear()
     * chachedStream // Still has all the items.
     * ```
     *
     * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
     */
    cache(): DataStream<Item>;
    /**
     * Get the distinct values of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     *
     * @typeParam T - The type of the distinct value.
     *
     * @returns A set of all distinct properties.
     */
    distinct<T>(callback: (item: Item, id: Id) => T): Set<T>;
    /**
     * Filter the items of the stream.
     *
     * @param callback - The function that decides whether an item will be included.
     *
     * @returns A new data stream with the filtered items.
     */
    filter(callback: (item: Item, id: Id) => boolean): DataStream<Item>;
    /**
     * Execute a callback for each item of the stream.
     *
     * @param callback - The function that will be invoked for each item.
     */
    forEach(callback: (item: Item, id: Id) => boolean): void;
    /**
     * Map the items into a different type.
     *
     * @param callback - The function that does the conversion.
     *
     * @typeParam Mapped - The type of the item after mapping.
     *
     * @returns A new data stream with the mapped items.
     */
    map<Mapped>(callback: (item: Item, id: Id) => Mapped): DataStream<Mapped>;
    /**
     * Get the item with the maximum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     *
     * @returns The item with the maximum if found otherwise null.
     */
    max(callback: (item: Item, id: Id) => number): Item | null;
    /**
     * Get the item with the minimum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     *
     * @returns The item with the minimum if found otherwise null.
     */
    min(callback: (item: Item, id: Id) => number): Item | null;
    /**
     * Reduce the items into a single value.
     *
     * @param callback - The function that does the reduction.
     * @param accumulator - The initial value of the accumulator.
     *
     * @typeParam T - The type of the accumulated value.
     *
     * @returns The reduced value.
     */
    reduce<T>(callback: (accumulator: T, item: Item, id: Id) => T, accumulator: T): T;
    /**
     * Sort the items.
     *
     * @param callback - Item comparator.
     *
     * @returns A new stream with sorted items.
     */
    sort(callback: (itemA: Item, itemB: Item, idA: Id, idB: Id) => number): DataStream<Item>;
}

/**
 * Initial DataSet configuration object.
 *
 * @typeParam IdProp - Name of the property that contains the id.
 */
interface DataSetInitialOptions<IdProp extends string> {
    /**
     * The name of the field containing the id of the items. When data is fetched from a server which uses some specific field to identify items, this field name can be specified in the DataSet using the option `fieldId`. For example [CouchDB](http://couchdb.apache.org/) uses the field `'_id'` to identify documents.
     */
    fieldId?: IdProp;
    /**
     * Queue data changes ('add', 'update', 'remove') and flush them at once. The queue can be flushed manually by calling `DataSet.flush()`, or can be flushed after a configured delay or maximum number of entries.
     *
     * When queue is true, a queue is created with default options. Options can be specified by providing an object.
     */
    queue?: QueueOptions | false;
}
/** DataSet configuration object. */
interface DataSetOptions {
    /**
     * Queue configuration object or false if no queue should be used.
     *
     * - If false and there was a queue before it will be flushed and then removed.
     * - If [[QueueOptions]] the existing queue will be reconfigured or a new queue will be created.
     */
    queue?: Queue | QueueOptions | false;
}
/**
 * # DataSet
 *
 * Vis.js comes with a flexible DataSet, which can be used to hold and
 * manipulate unstructured data and listen for changes in the data. The DataSet
 * is key/value based. Data items can be added, updated and removed from the
 * DataSet, and one can subscribe to changes in the DataSet. The data in the
 * DataSet can be filtered and ordered. Data can be normalized when appending it
 * to the DataSet as well.
 *
 * ## Example
 *
 * The following example shows how to use a DataSet.
 *
 * ```javascript
 * // create a DataSet
 * var options = {};
 * var data = new vis.DataSet(options);
 *
 * // add items
 * // note that the data items can contain different properties and data formats
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // subscribe to any change in the DataSet
 * data.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an existing item
 * data.update({id: 2, group: 1});
 *
 * // remove an item
 * data.remove(4);
 *
 * // get all ids
 * var ids = data.getIds();
 * console.log('ids', ids);
 *
 * // get a specific item
 * var item1 = data.get(1);
 * console.log('item1', item1);
 *
 * // retrieve a filtered subset of the data
 * var items = data.get({
 *   filter: function (item) {
 *     return item.group == 1;
 *   }
 * });
 * console.log('filtered items', items);
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */
export class DataSet<Item extends PartItem<IdProp>, IdProp extends string = "id"> extends DataSetPart<Item, IdProp> implements DataInterface<Item, IdProp> {
    /** Flush all queued calls. */
    flush?: () => void;
    /** @inheritDoc */
    length: number;
    /** @inheritDoc */
    get idProp(): IdProp;
    private readonly _options;
    private readonly _data;
    private readonly _idProp;
    private _queue;
    /**
     * @param options - DataSet configuration.
     */
    constructor(options?: DataSetInitialOptions<IdProp>);
    /**
     * @param data - An initial set of items for the new instance.
     * @param options - DataSet configuration.
     */
    constructor(data: Item[], options?: DataSetInitialOptions<IdProp>);
    /**
     * Set new options.
     *
     * @param options - The new options.
     */
    setOptions(options?: DataSetOptions): void;
    /**
     * Add a data item or an array with items.
     *
     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet()
     *
     * // add items
     * const ids = data.add([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { text: 'item without an id' }
     * ])
     *
     * console.log(ids) // [1, 2, '<UUIDv4>']
     * ```
     *
     * @param data - Items to be added (ids will be generated if missing).
     * @param senderId - Sender id.
     *
     * @returns addedIds - Array with the ids (generated if not present) of the added items.
     *
     * @throws When an item with the same id as any of the added items already exists.
     */
    add(data: Item | Item[], senderId?: Id | null): (string | number)[];
    /**
     * Update existing items. When an item does not exist, it will be created.
     *
     * @remarks
     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
     *
     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' },
     *   { id: 4, text: 'item 4 (new)' }
     * ])
     *
     * console.log(ids) // [2, 4]
     * ```
     *
     * ## Warning for TypeScript users
     * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
     *
     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
     * @param senderId - Sender id.
     *
     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
     *
     * @throws When the supplied data is neither an item nor an array of items.
     */
    update(data: DeepPartial<Item> | DeepPartial<Item>[], senderId?: Id | null): Id[];
    /**
     * Update existing items. When an item does not exist, an error will be thrown.
     *
     * @remarks
     * The provided properties will be deeply merged into the existing item.
     * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
     *
     * After the items are updated, the DataSet will trigger an event `update`.
     * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' },
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' }, // works
     *   // { id: 4, text: 'item 4 (new)' }, // would throw
     *   // { text: 'item 4 (new)' }, // would also throw
     * ])
     *
     * console.log(ids) // [2]
     * ```
     *
     * @param data - Updates (the id and optionally other props) to the items in this data set.
     * @param senderId - Sender id.
     *
     * @returns updatedIds - The ids of the updated items.
     *
     * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
     */
    updateOnly(data: UpdateItem<Item, IdProp> | UpdateItem<Item, IdProp>[], senderId?: Id | null): Id[];
    /** @inheritDoc */
    get(): FullItem<Item, IdProp>[];
    /** @inheritDoc */
    get(options: DataInterfaceGetOptionsArray<Item>): FullItem<Item, IdProp>[];
    /** @inheritDoc */
    get(options: DataInterfaceGetOptionsObject<Item>): Record<Id, FullItem<Item, IdProp>>;
    /** @inheritDoc */
    get(options: DataInterfaceGetOptions<Item>): FullItem<Item, IdProp>[] | Record<Id, FullItem<Item, IdProp>>;
    /** @inheritDoc */
    get(id: Id): null | FullItem<Item, IdProp>;
    /** @inheritDoc */
    get(id: Id, options: DataInterfaceGetOptionsArray<Item>): null | FullItem<Item, IdProp>;
    /** @inheritDoc */
    get(id: Id, options: DataInterfaceGetOptionsObject<Item>): Record<Id, FullItem<Item, IdProp>>;
    /** @inheritDoc */
    get(id: Id, options: DataInterfaceGetOptions<Item>): null | FullItem<Item, IdProp> | Record<Id, FullItem<Item, IdProp>>;
    /** @inheritDoc */
    get(ids: Id[]): FullItem<Item, IdProp>[];
    /** @inheritDoc */
    get(ids: Id[], options: DataInterfaceGetOptionsArray<Item>): FullItem<Item, IdProp>[];
    /** @inheritDoc */
    get(ids: Id[], options: DataInterfaceGetOptionsObject<Item>): Record<Id, FullItem<Item, IdProp>>;
    /** @inheritDoc */
    get(ids: Id[], options: DataInterfaceGetOptions<Item>): FullItem<Item, IdProp>[] | Record<Id, FullItem<Item, IdProp>>;
    /** @inheritDoc */
    get(ids: Id | Id[], options?: DataInterfaceGetOptions<Item>): null | FullItem<Item, IdProp> | FullItem<Item, IdProp>[] | Record<Id, FullItem<Item, IdProp>>;
    /** @inheritDoc */
    getIds(options?: DataInterfaceGetIdsOptions<Item>): Id[];
    /** @inheritDoc */
    getDataSet(): DataSet<Item, IdProp>;
    /** @inheritDoc */
    forEach(callback: (item: Item, id: Id) => void, options?: DataInterfaceForEachOptions<Item>): void;
    /** @inheritDoc */
    map<T>(callback: (item: Item, id: Id) => T, options?: DataInterfaceMapOptions<Item, T>): T[];
    private _filterFields;
    /**
     * Sort the provided array with items.
     *
     * @param items - Items to be sorted in place.
     * @param order - A field name or custom sort function.
     *
     * @typeParam T - The type of the items in the items array.
     */
    private _sort;
    /**
     * Remove an item or multiple items by “reference” (only the id is used) or by id.
     *
     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
     *
     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // remove items
     * const ids = data.remove([2, { id: 3 }, 4])
     *
     * console.log(ids) // [2, 3]
     * ```
     *
     * @param id - One or more items or ids of items to be removed.
     * @param senderId - Sender id.
     *
     * @returns The ids of the removed items.
     */
    remove(id: Id | Item | (Id | Item)[], senderId?: Id | null): Id[];
    /**
     * Remove an item by its id or reference.
     *
     * @param id - Id of an item or the item itself.
     *
     * @returns The removed item if removed, null otherwise.
     */
    private _remove;
    /**
     * Clear the entire data set.
     *
     * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * @param senderId - Sender id.
     *
     * @returns removedIds - The ids of all removed items.
     */
    clear(senderId?: Id | null): Id[];
    /**
     * Find the item with maximum value of a specified field.
     *
     * @param field - Name of the property that should be searched for max value.
     *
     * @returns Item containing max value, or null if no items.
     */
    max(field: keyof Item): Item | null;
    /**
     * Find the item with minimum value of a specified field.
     *
     * @param field - Name of the property that should be searched for min value.
     *
     * @returns Item containing min value, or null if no items.
     */
    min(field: keyof Item): Item | null;
    distinct<T extends keyof Item>(prop: T): Item[T][];
    distinct(prop: string): unknown[];
    /**
     * Add a single item. Will fail when an item with the same id already exists.
     *
     * @param item - A new item to be added.
     *
     * @returns Added item's id. An id is generated when it is not present in the item.
     */
    private _addItem;
    /**
     * Update a single item: merge with existing item.
     * Will fail when the item has no id, or when there does not exist an item with the same id.
     *
     * @param update - The new item
     *
     * @returns The id of the updated item.
     */
    private _updateItem;
    /** @inheritDoc */
    stream(ids?: Iterable<Id>): DataStream<Item>;
    get testLeakData(): Map<Id, FullItem<Item, IdProp>>;
    get testLeakIdProp(): IdProp;
    get testLeakOptions(): DataSetInitialOptions<IdProp>;
    get testLeakQueue(): Queue<this> | null;
    set testLeakQueue(v: Queue<this> | null);
}

/** Valid id type. */
export type Id = number | string;
/** Nullable id type. */
export type OptId = undefined | null | Id;
/**
 * Make an object deeply partial.
 */
export type DeepPartial<T> = T extends any[] | Function | Node ? T : T extends object ? {
    [key in keyof T]?: DeepPartial<T[key]>;
} : T;
/**
 * An item that may ([[Id]]) or may not (absent, undefined or null) have an id property.
 *
 * @typeParam IdProp - Name of the property that contains the id.
 */
export type PartItem<IdProp extends string> = Partial<Record<IdProp, OptId>>;
/**
 * An item that has a property containing an id and all other required properties of given item type.
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */
export type FullItem<Item extends PartItem<IdProp>, IdProp extends string> = Item & Record<IdProp, Id>;
/**
 * An item that has a property containing an id and optionally other properties of given item type.
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */
export type UpdateItem<Item extends PartItem<IdProp>, IdProp extends string> = Assignable<FullItem<Item, IdProp>> & Record<IdProp, Id>;
/** Add event payload. */
interface AddEventPayload {
    /** Ids of added items. */
    items: Id[];
}
/** Update event payload. */
interface UpdateEventPayload<Item, IdProp extends string> {
    /** Ids of updated items. */
    items: Id[];
    /** Items as they were before this update. */
    oldData: FullItem<Item, IdProp>[];
    /**
     * Items as they are now.
     *
     * @deprecated Just get the data from the data set or data view.
     */
    data: FullItem<Item, IdProp>[];
}
/** Remove event payload. */
interface RemoveEventPayload<Item, IdProp extends string> {
    /** Ids of removed items. */
    items: Id[];
    /** Items as they were before their removal. */
    oldData: FullItem<Item, IdProp>[];
}
/**
 * Map of event payload types (event name → payload).
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */
interface EventPayloads<Item, IdProp extends string> {
    add: AddEventPayload;
    update: UpdateEventPayload<Item, IdProp>;
    remove: RemoveEventPayload<Item, IdProp>;
}
/**
 * Map of event callback types (event name → callback).
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */
interface EventCallbacks<Item, IdProp extends string> {
    /**
     * @param name - The name of the event ([[EventName]]).
     * @param payload - Data about the items affected by this event.
     * @param senderId - A senderId, optionally provided by the application code which triggered the event. If senderId is not provided, the argument will be `null`.
     */
    add(name: "add", payload: AddEventPayload | null, senderId?: Id | null): void;
    /**
     * @param name - The name of the event ([[EventName]]).
     * @param payload - Data about the items affected by this event.
     * @param senderId - A senderId, optionally provided by the application code which triggered the event. If senderId is not provided, the argument will be `null`.
     */
    update(name: "update", payload: UpdateEventPayload<Item, IdProp> | null, senderId?: Id | null): void;
    /**
     * @param name - The name of the event ([[EventName]]).
     * @param payload - Data about the items affected by this event.
     * @param senderId - A senderId, optionally provided by the application code which triggered the event. If senderId is not provided, the argument will be `null`.
     */
    remove(name: "remove", payload: RemoveEventPayload<Item, IdProp> | null, senderId?: Id | null): void;
}
/**
 * Map of event callback types including any event (event name → callback).
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */
interface EventCallbacksWithAny<Item, IdProp extends string> extends EventCallbacks<Item, IdProp> {
    /**
     * @param name - The name of the event ([[EventName]]).
     * @param payload - Data about the items affected by this event.
     * @param senderId - A senderId, optionally provided by the application code which triggered the event. If senderId is not provided, the argument will be `null`.
     */
    "*"<N extends keyof EventCallbacks<Item, IdProp>>(name: N, payload: EventPayloads<Item, IdProp>[N], senderId?: Id | null): void;
}
/**
 * Data interface order parameter.
 * - A string value determines which property will be used for sorting (using < and > operators for numeric comparison).
 * - A function will be used the same way as in Array.sort.
 *
 * @typeParam Item - Item type that may or may not have an id.
 */
export type DataInterfaceOrder<Item> = keyof Item | ((a: Item, b: Item) => number);
/**
 * Data interface get options (return type independent).
 *
 * @typeParam Item - Item type that may or may not have an id.
 */
interface DataInterfaceGetOptionsBase<Item> {
    /**
     * An array with field names, or an object with current field name and new field name that the field is returned as. By default, all properties of the items are emitted. When fields is defined, only the properties whose name is specified in fields will be included in the returned items.
     *
     * @remarks
     * **Warning**: There is no TypeScript support for this.
     */
    fields?: string[] | Record<string, string>;
    /** Items can be filtered on specific properties by providing a filter function. A filter function is executed for each of the items in the DataSet, and is called with the item as parameter. The function must return a boolean. All items for which the filter function returns true will be emitted. */
    filter?: (item: Item) => boolean;
    /** Order the items by a field name or custom sort function. */
    order?: DataInterfaceOrder<Item>;
}
/**
 * Data interface get options (returns a single item or an array).
 *
 * @remarks
 * Whether an item or and array of items is returned is determined by the type of the id(s) argument.
 * If an array of ids is requested an array of items will be returned.
 * If a single id is requested a single item (or null if the id doesn't correspond to any item) will be returned.
 *
 * @typeParam Item - Item type that may or may not have an id.
 */
interface DataInterfaceGetOptionsArray<Item> extends DataInterfaceGetOptionsBase<Item> {
    /** Items will be returned as a single item (if invoked with an id) or an array of items (if invoked with an array of ids). */
    returnType?: undefined | "Array";
}
/**
 * Data interface get options (returns an object).
 *
 * @remarks
 * The returned object has ids as keys and items as values of corresponding ids.
 *
 * @typeParam Item - Item type that may or may not have an id.
 */
interface DataInterfaceGetOptionsObject<Item> extends DataInterfaceGetOptionsBase<Item> {
    /** Items will be returned as an object map (id → item). */
    returnType: "Object";
}
/**
 * Data interface get options (returns single item, an array or object).
 *
 * @typeParam Item - Item type that may or may not have an id.
 */
export type DataInterfaceGetOptions<Item> = DataInterfaceGetOptionsArray<Item> | DataInterfaceGetOptionsObject<Item>;
/**
 * Data interface get ids options.
 *
 * @typeParam Item - Item type that may or may not have an id.
 */
interface DataInterfaceGetIdsOptions<Item> {
    /** Items can be filtered on specific properties by providing a filter function. A filter function is executed for each of the items in the DataSet, and is called with the item as parameter. The function must return a boolean. All items for which the filter function returns true will be emitted. */
    filter?: (item: Item) => boolean;
    /** Order the items by a field name or custom sort function. */
    order?: DataInterfaceOrder<Item>;
}
/**
 * Data interface for each options.
 *
 * @typeParam Item - Item type that may or may not have an id.
 */
interface DataInterfaceForEachOptions<Item> {
    /** An array with field names, or an object with current field name and new field name that the field is returned as. By default, all properties of the items are emitted. When fields is defined, only the properties whose name is specified in fields will be included in the returned items. */
    fields?: string[] | Record<string, string>;
    /** Items can be filtered on specific properties by providing a filter function. A filter function is executed for each of the items in the DataSet, and is called with the item as parameter. The function must return a boolean. All items for which the filter function returns true will be emitted. */
    filter?: (item: Item) => boolean;
    /** Order the items by a field name or custom sort function. */
    order?: DataInterfaceOrder<Item>;
}
/**
 * Data interface map oprions.
 *
 * @typeParam Original - The original item type in the data.
 * @typeParam Mapped - The type after mapping.
 */
interface DataInterfaceMapOptions<Original, Mapped> {
    /** An array with field names, or an object with current field name and new field name that the field is returned as. By default, all properties of the items are emitted. When fields is defined, only the properties whose name is specified in fields will be included in the returned items. */
    fields?: string[] | Record<string, string>;
    /** Items can be filtered on specific properties by providing a filter function. A filter function is executed for each of the items in the DataSet, and is called with the item as parameter. The function must return a boolean. All items for which the filter function returns true will be emitted. */
    filter?: (item: Original) => boolean;
    /** Order the items by a field name or custom sort function. */
    order?: DataInterfaceOrder<Mapped>;
}
/**
 * Common interface for data sets and data view.
 *
 * @typeParam Item - Item type that may or may not have an id (missing ids will be generated upon insertion).
 * @typeParam IdProp - Name of the property on the Item type that contains the id.
 */
interface DataInterface<Item extends PartItem<IdProp>, IdProp extends string = "id"> {
    /** The number of items. */
    length: number;
    /** The key of id property. */
    idProp: IdProp;
    /**
     * Add a universal event listener.
     *
     * @remarks The `*` event is triggered when any of the events `add`, `update`, and `remove` occurs.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    on(event: "*", callback: EventCallbacksWithAny<Item, IdProp>["*"]): void;
    /**
     * Add an `add` event listener.
     *
     * @remarks The `add` event is triggered when an item or a set of items is added, or when an item is updated while not yet existing.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    on(event: "add", callback: EventCallbacksWithAny<Item, IdProp>["add"]): void;
    /**
     * Add a `remove` event listener.
     *
     * @remarks The `remove` event is triggered when an item or a set of items is removed.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    on(event: "remove", callback: EventCallbacksWithAny<Item, IdProp>["remove"]): void;
    /**
     * Add an `update` event listener.
     *
     * @remarks The `update` event is triggered when an existing item or a set of existing items is updated.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    on(event: "update", callback: EventCallbacksWithAny<Item, IdProp>["update"]): void;
    /**
     * Remove a universal event listener.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    off(event: "*", callback: EventCallbacksWithAny<Item, IdProp>["*"]): void;
    /**
     * Remove an `add` event listener.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    off(event: "add", callback: EventCallbacksWithAny<Item, IdProp>["add"]): void;
    /**
     * Remove a `remove` event listener.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    off(event: "remove", callback: EventCallbacksWithAny<Item, IdProp>["remove"]): void;
    /**
     * Remove an `update` event listener.
     *
     * @param event - Event name.
     * @param callback - Callback function.
     */
    off(event: "update", callback: EventCallbacksWithAny<Item, IdProp>["update"]): void;
    /**
     * Get all the items.
     *
     * @returns An array containing all the items.
     */
    get(): FullItem<Item, IdProp>[];
    /**
     * Get all the items.
     *
     * @param options - Additional options.
     *
     * @returns An array containing requested items.
     */
    get(options: DataInterfaceGetOptionsArray<Item>): FullItem<Item, IdProp>[];
    /**
     * Get all the items.
     *
     * @param options - Additional options.
     *
     * @returns An object map of items (may be an empty object if there are no items).
     */
    get(options: DataInterfaceGetOptionsObject<Item>): Record<Id, FullItem<Item, IdProp>>;
    /**
     * Get all the items.
     *
     * @param options - Additional options.
     *
     * @returns An array containing requested items or if requested an object map of items (may be an empty object if there are no items).
     */
    get(options: DataInterfaceGetOptions<Item>): FullItem<Item, IdProp>[] | Record<Id, FullItem<Item, IdProp>>;
    /**
     * Get one item.
     *
     * @param id - The id of the item.
     *
     * @returns The item or null if the id doesn't correspond to any item.
     */
    get(id: Id): null | FullItem<Item, IdProp>;
    /**
     * Get one item.
     *
     * @param id - The id of the item.
     * @param options - Additional options.
     *
     * @returns The item or null if the id doesn't correspond to any item.
     */
    get(id: Id, options: DataInterfaceGetOptionsArray<Item>): null | FullItem<Item, IdProp>;
    /**
     * Get one item.
     *
     * @param id - The id of the item.
     * @param options - Additional options.
     *
     * @returns An object map of items (may be an empty object if no item was found).
     */
    get(id: Id, options: DataInterfaceGetOptionsObject<Item>): Record<Id, FullItem<Item, IdProp>>;
    /**
     * Get one item.
     *
     * @param id - The id of the item.
     * @param options - Additional options.
     *
     * @returns The item if found or null otherwise. If requested an object map with 0 to 1 items.
     */
    get(id: Id, options: DataInterfaceGetOptions<Item>): null | FullItem<Item, IdProp> | Record<Id, FullItem<Item, IdProp>>;
    /**
     * Get multiple items.
     *
     * @param ids - An array of requested ids.
     *
     * @returns An array of found items (ids that do not correspond to any item are omitted).
     */
    get(ids: Id[]): FullItem<Item, IdProp>[];
    /**
     * Get multiple items.
     *
     * @param ids - An array of requested ids.
     * @param options - Additional options.
     *
     * @returns An array of found items (ids that do not correspond to any item are omitted).
     */
    get(ids: Id[], options: DataInterfaceGetOptionsArray<Item>): FullItem<Item, IdProp>[];
    /**
     * Get multiple items.
     *
     * @param ids - An array of requested ids.
     * @param options - Additional options.
     *
     * @returns An object map of items (may be an empty object if no item was found).
     */
    get(ids: Id[], options: DataInterfaceGetOptionsObject<Item>): Record<Id, FullItem<Item, IdProp>>;
    /**
     * Get multiple items.
     *
     * @param ids - An array of requested ids.
     * @param options - Additional options.
     *
     * @returns An array of found items (ids that do not correspond to any item are omitted).
     * If requested an object map of items (may be an empty object if no item was found).
     */
    get(ids: Id[], options: DataInterfaceGetOptions<Item>): FullItem<Item, IdProp>[] | Record<Id, FullItem<Item, IdProp>>;
    /**
     * Get items.
     *
     * @param ids - Id or ids to be returned.
     * @param options - Options to specify iteration details.
     *
     * @returns The items (format is determined by ids (single or array) and the options.
     */
    get(ids: Id | Id[], options?: DataInterfaceGetOptions<Item>): null | FullItem<Item, IdProp> | FullItem<Item, IdProp>[] | Record<Id, FullItem<Item, IdProp>>;
    /**
     * Get the DataSet to which the instance implementing this interface is connected.
     * In case there is a chain of multiple DataViews, the root DataSet of this chain is returned.
     *
     * @returns The data set that actually contains the data.
     */
    getDataSet(): DataSet<Item, IdProp>;
    /**
     * Get ids of items.
     *
     * @remarks
     * No guarantee is given about the order of returned ids unless an ordering function is supplied.
     *
     * @param options - Additional configuration.
     *
     * @returns An array of requested ids.
     */
    getIds(options?: DataInterfaceGetIdsOptions<Item>): Id[];
    /**
     * Execute a callback function for each item.
     *
     * @remarks
     * No guarantee is given about the order of iteration unless an ordering function is supplied.
     *
     * @param callback - Executed in similar fashion to Array.forEach callback, but instead of item, index, array receives item, id.
     * @param options - Options to specify iteration details.
     */
    forEach(callback: (item: Item, id: Id) => void, options?: DataInterfaceForEachOptions<Item>): void;
    /**
     * Map each item into different item and return them as an array.
     *
     * @remarks
     * No guarantee is given about the order of iteration even if ordering function is supplied (the items are sorted after the mapping).
     *
     * @param callback - Array.map-like callback, but only with the first two params.
     * @param options - Options to specify iteration details.
     *
     * @returns The mapped items.
     */
    map<T>(callback: (item: Item, id: Id) => T, options?: DataInterfaceMapOptions<Item, T>): T[];
    /**
     * Stream.
     *
     * @param ids - Ids of the items to be included in this stream (missing are ignored), all if omitted.
     *
     * @returns The data stream for this data set.
     */
    stream(ids?: Iterable<Id>): DataStream<Item>;
}

// Type definitions for vis.js 8.3.2

type DataInterfaceEdges = DataInterface<Edge, 'id'>
type DataInterfaceNodes = DataInterface<Node$1, 'id'>

type IdType = string | number;
type DirectionType = 'from' | 'to';

/**
 * If true (default) or an Object, the range is animated smoothly to the new window.
 * An object can be provided to specify duration and easing function.
 * Default duration is 500 ms, and default easing function is 'easeInOutQuad'.
 */
type TimelineAnimationType = boolean | AnimationOptions;

type NetworkEvents =
  'click' |
  'doubleClick' |
  'oncontext' |
  'hold' |
  'release' |
  'select' |
  'selectNode' |
  'selectEdge' |
  'deselectNode' |
  'deselectEdge' |
  'dragStart' |
  'dragging' |
  'dragEnd' |
  'controlNodeDragging' |
  'controlNodeDragEnd' |
  'hoverNode' |
  'blurNode' |
  'hoverEdge' |
  'blurEdge' |
  'zoom' |
  'showPopup' |
  'hidePopup' |
  'startStabilizing' |
  'stabilizationProgress' |
  'stabilizationIterationsDone' |
  'stabilized' |
  'resize' |
  'initRedraw' |
  'beforeDrawing' |
  'afterDrawing' |
  'animationFinished' |
  'configChange';

/**
 * Network is a visualization to display networks and networks consisting of nodes and edges.
 * The visualization is easy to use and supports custom shapes, styles, colors, sizes, images, and more.
 * The network visualization works smooth on any modern browser for up to a few thousand nodes and edges.
 * To handle a larger amount of nodes, Network has clustering support. Network uses HTML canvas for rendering.
 */
export class Network {
  /**
   * Creates an instance of Network.
   *
   * @param container the HTML element representing the network container
   * @param data network data
   * @param [options] optional network options
   */
  constructor(container: HTMLElement, data: Data$1, options?: Options$4);

  /**
   * 	Remove the network from the DOM and remove all Hammer bindings and references.
   */
  destroy(): void;

  /**
   * Override all the data in the network.
   * If stabilization is enabled in the physics module,
   * the network will stabilize again.
   * This method is also performed when first initializing the network.
   *
   * @param data network data
   */
  setData(data: Data$1): void;

  /**
   * Set the options.
   * All available options can be found in the modules above.
   * Each module requires it's own container with the module name to contain its options.
   *
   * @param options network options
   */
  setOptions(options: Options$4): void;

  /**
   * Set an event listener.
   * Depending on the type of event you get different parameters for the callback function.
   *
   * @param eventName the name of the event, f.e. 'click'
   * @param callback the callback function that will be raised
   */
  on(eventName: NetworkEvents, callback: (params?: any) => void): void;

  /**
   * Remove an event listener.
   * The function you supply has to be the exact same as the one you used in the on function.
   * If no function is supplied, all listeners will be removed.
   *
   * @param eventName the name of the event, f.e. 'click'
   * @param [callback] the exact same callback function that was used when calling 'on'
   */
  off(eventName: NetworkEvents, callback?: (params?: any) => void): void;

  /**
   * Set an event listener only once.
   * After it has taken place, the event listener will be removed.
   * Depending on the type of event you get different parameters for the callback function.
   *
   * @param eventName the name of the event, f.e. 'click'
   * @param callback the callback function that will be raised once
   */
  once(eventName: NetworkEvents, callback: (params?: any) => void): void;

  /**
   * This function converts canvas coordinates to coordinates on the DOM.
   * Input and output are in the form of {x:Number, y:Number} (IPosition interface).
   * The DOM values are relative to the network container.
   *
   * @param position the canvas coordinates
   * @returns the DOM coordinates
   */
  canvasToDOM(position: Position): Position;

  /**
   * This function converts DOM coordinates to coordinates on the canvas.
   * Input and output are in the form of {x:Number,y:Number} (IPosition interface).
   * The DOM values are relative to the network container.
   *
   * @param position the DOM coordinates
   * @returns the canvas coordinates
   */
  DOMtoCanvas(position: Position): Position;

  /**
   * Redraw the network.
   */
  redraw(): void;

  /**
   * Set the size of the canvas.
   * This is automatically done on a window resize.
   *
   * @param width width in a common format, f.e. '100px'
   * @param height height in a common format, f.e. '100px'
   */
  setSize(width: string, height: string): void;

  /**
   * The joinCondition function is presented with all nodes.
   */
  cluster(options?: ClusterOptions): void;

  /**
   * 	This method looks at the provided node and makes a cluster of it and all it's connected nodes.
   * The behaviour can be customized by proving the options object.
   * All options of this object are explained below.
   * The joinCondition is only presented with the connected nodes.
   *
   * @param nodeId the id of the node
   * @param [options] the cluster options
   */
  clusterByConnection(nodeId: string, options?: ClusterOptions): void;

  /**
   * This method checks all nodes in the network and those with a equal or higher
   * amount of edges than specified with the hubsize qualify.
   * If a hubsize is not defined, the hubsize will be determined as the average
   * value plus two standard deviations.
   * For all qualifying nodes, clusterByConnection is performed on each of them.
   * The options object is described for clusterByConnection and does the same here.
   *
   * @param [hubsize] optional hubsize
   * @param [options] optional cluster options
   */
  clusterByHubsize(hubsize?: number, options?: ClusterOptions): void;

  /**
   * This method will cluster all nodes with 1 edge with their respective connected node.
   *
   * @param [options] optional cluster options
   */
  clusterOutliers(options?: ClusterOptions): void;

  /**
   * Nodes can be in clusters.
   * Clusters can also be in clusters.
   * This function returns an array of nodeIds showing where the node is.
   *
   * Example:
   * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',
   * cluster 'C' contains node 'fred'.
   *
   * network.clustering.findNode('fred') will return ['A','B','C','fred'].
   *
   * @param nodeId the node id.
   * @returns an array of nodeIds showing where the node is
   */
  findNode(nodeId: IdType): IdType[];

  /**
   * Similar to findNode in that it returns all the edge ids that were
   * created from the provided edge during clustering.
   *
   * @param baseEdgeId the base edge id
   * @returns an array of edgeIds
   */
  getClusteredEdges(baseEdgeId: IdType): IdType[];

  /**
   * When a clusteredEdgeId is available, this method will return the original
   * baseEdgeId provided in data.edges ie.
   * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.
   * This method can then be used to return the baseEdgeId.
   */
  getBaseEdge(clusteredEdgeId: IdType): IdType;

  /**
   * For the given clusteredEdgeId, this method will return all the original
   * base edge id's provided in data.edges.
   * For a non-clustered (i.e. 'base') edge, clusteredEdgeId is returned.
   * Only the base edge id's are returned.
   * All clustered edges id's under clusteredEdgeId are skipped,
   * but scanned recursively to return their base id's.
   */
  getBaseEdges(clusteredEdgeId: IdType): IdType[];

  /**
   * Visible edges between clustered nodes are not the same edge as the ones provided
   * in data.edges passed on network creation. With each layer of clustering, copies of
   * the edges between clusters are created and the previous edges are hidden,
   * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)
   * and applys the options to it and any edges that were created from it while clustering.
   */
  updateEdge(startEdgeId: IdType, options?: EdgeOptions): void;

  /**
   * Clustered Nodes when created are not contained in the original data.nodes
   * passed on network creation. This method updates the cluster node.
   */
  updateClusteredNode(clusteredNodeId: IdType, options?: NodeOptions): void;

  /**
   * Returns true if the node whose ID has been supplied is a cluster.
   *
   * @param nodeId the node id.
   */
  isCluster(nodeId: IdType): boolean;

  /**
   * Returns an array of all nodeIds of the nodes that
   * would be released if you open the cluster.
   *
   * @param clusterNodeId the id of the cluster node
   */
  getNodesInCluster(clusterNodeId: IdType): IdType[];

  /**
   * Opens the cluster, releases the contained nodes and edges,
   * removing the cluster node and cluster edges.
   * The options object is optional and currently supports one option,
   * releaseFunction, which is a function that can be used to manually
   * position the nodes after the cluster is opened.
   *
   * @param nodeId the node id
   * @param [options] optional open cluster options
   */
  openCluster(nodeId: IdType, options?: OpenClusterOptions): void;

  /**
   * If you like the layout of your network
   * and would like it to start in the same way next time,
   * ask for the seed using this method and put it in the layout.randomSeed option.
   *
   * @returns the current seed of the network.
   */
  getSeed(): number | string;

  /**
   * 	Programatically enable the edit mode.
   * Similar effect to pressing the edit button.
   */
  enableEditMode(): void;

  /**
   * Programatically disable the edit mode.
   * Similar effect to pressing the close icon (small cross in the corner of the toolbar).
   */
  disableEditMode(): void;

  /**
   * 	Go into addNode mode. Having edit mode or manipulation enabled is not required.
   * To get out of this mode, call disableEditMode().
   * The callback functions defined in handlerFunctions still apply.
   * To use these methods without having the manipulation GUI, make sure you set enabled to false.
   */
  addNodeMode(): void;

  /**
   * Edit the selected node.
   * The explaination from addNodeMode applies here as well.
   */
  editNode(): void;

  /**
   * Go into addEdge mode.
   * The explaination from addNodeMode applies here as well.
   */
  addEdgeMode(): void;

  /**
   * Go into editEdge mode.
   * The explaination from addNodeMode applies here as well.
   */
  editEdgeMode(): void;

  /**
   * Delete selected.
   * Having edit mode or manipulation enabled is not required.
   */
  deleteSelected(): void;

  /**
   * Returns the x y positions in canvas space of a requested node or array of nodes.
   * 
   * @remarks
   * - If `nodeIds` is supplied as a single id that does not correspond
   * to a node in the network, this function will return an empty object.
   * - If `nodeIds` is supplied as an array of ids, but one or more do not correspond to a node in the network, the
   * returned object will *not* include entries for the non-existent node positions.
   *
   * @param nodeIds - Either an array of node ids or a single node id. If not supplied, all node ids in the network will be used.
   * @returns A an object containing the x y positions in canvas space of the nodes in the network, keyed by id.
   */
  getPositions(nodeIds?: IdType[] | IdType): { [nodeId: string]: Position };

  /**
   * Retrieves the x y position of a specific id.
   * 
   * @param id - a node id
   * @returns the x y position in canvas space of the requested node.
   * 
   * @throws {@link TypeError} 
   *  Thrown if an undefined or null id is provided as a parameter.
   * @throws {@link ReferenceError} 
   *  Thrown if the id provided as a parameter does not correspond to a node in the network.
   */
  getPosition(nodeId: IdType): Position;

  /**
   * 	When using the vis.DataSet to load your nodes into the network,
   * this method will put the X and Y positions of all nodes into that dataset.
   * If you're loading your nodes from a database and have this dynamically coupled with the DataSet,
   * you can use this to stablize your network once, then save the positions in that database
   * through the DataSet so the next time you load the nodes, stabilization will be near instantaneous.
   *
   * If the nodes are still moving and you're using dynamic smooth edges (which is on by default),
   * you can use the option stabilization.onlyDynamicEdges in the physics module to improve initialization time.
   *
   * This method does not support clustering.
   * At the moment it is not possible to cache positions when using clusters since
   * they cannot be correctly initialized from just the positions.
   */
  storePositions(): void;

  /**
   * You can use this to programatically move a node.
   * The supplied x and y positions have to be in canvas space!
   *
   * @param nodeId the node that will be moved
   * @param x new canvas space x position
   * @param y new canvas space y position
   */
  moveNode(nodeId: IdType, x: number, y: number): void;

  /**
   * Returns a bounding box for the node including label.
   *
   */
  getBoundingBox(nodeId: IdType): BoundingBox;

  /**
   * Returns an array of nodeIds of the all the nodes that are directly connected to this node.
   * If you supply an edgeId, vis will first match the id to nodes.
   * If no match is found, it will search in the edgelist and return an array: [fromId, toId].
   *
   * @param nodeOrEdgeId a node or edge id
   */
  getConnectedNodes(nodeOrEdgeId: IdType, direction?: DirectionType): IdType[] | Array<{ fromId: IdType, toId: IdType }>;

  /**
   * Returns an array of edgeIds of the edges connected to this node.
   *
   * @param nodeId the node id
   */
  getConnectedEdges(nodeId: IdType): IdType[];

  /**
   * Start the physics simulation.
   * This is normally done whenever needed and is only really useful
   * if you stop the simulation yourself and wish to continue it afterwards.
   */
  startSimulation(): void;

  /**
   * This stops the physics simulation and triggers a stabilized event.
   * Tt can be restarted by dragging a node,
   * altering the dataset or calling startSimulation().
   */
  stopSimulation(): void;

  /**
   * You can manually call stabilize at any time.
   * All the stabilization options above are used.
   * You can optionally supply the number of iterations it should do.
   *
   * @param [iterations] the number of iterations it should do
   */
  stabilize(iterations?: number): void;

  /**
   * Returns an object with selected nodes and edges ids.
   *
   */
  getSelection(): { nodes: IdType[], edges: IdType[] };

  /**
   * Returns an array of selected node ids like so:
   * [nodeId1, nodeId2, ..].
   *
   */
  getSelectedNodes(): IdType[];

  /**
   * Returns an array of selected edge ids like so:
   * [edgeId1, edgeId2, ..].
   *
   */
  getSelectedEdges(): IdType[];

  /**
   * Returns a nodeId or undefined.
   * The DOM positions are expected to be in pixels from the top left corner of the canvas.
   *
   */
  getNodeAt(position: Position): IdType;

  /**
   * Returns a edgeId or undefined.
   * The DOM positions are expected to be in pixels from the top left corner of the canvas.
   *
   */
  getEdgeAt(position: Position): IdType;

  /**
   * Selects the nodes corresponding to the id's in the input array.
   * If highlightEdges is true or undefined, the neighbouring edges will also be selected.
   * This method unselects all other objects before selecting its own objects. Does not fire events.
   *
   */
  selectNodes(nodeIds: IdType[], highlightEdges?: boolean): void;

  /**
   * Selects the edges corresponding to the id's in the input array.
   * This method unselects all other objects before selecting its own objects.
   * Does not fire events.
   *
   */
  selectEdges(edgeIds: IdType[]): void;

  /**
   * Sets the selection.
   * You can also pass only nodes or edges in selection object.
   *
   */
  setSelection(selection: { nodes?: IdType[], edges?: IdType[] }, options?: SelectionOptions): void;

  /**
   * Unselect all objects.
   * Does not fire events.
   */
  unselectAll(): void;

  /**
   * Returns the current scale of the network.
   * 1.0 is comparible to 100%, 0 is zoomed out infinitely.
   *
   * @returns the current scale of the network
   */
  getScale(): number;

  /**
   * Returns the current central focus point of the view in the form: { x: {Number}, y: {Number} }
   *
   * @returns the view position;
   */
  getViewPosition(): Position;

  /**
   * Zooms out so all nodes fit on the canvas.
   *
   * @param [options] All options are optional for the fit method
   */
  fit(options?: FitOptions): void;

  /**
   * You can focus on a node with this function.
   * What that means is the view will lock onto that node, if it is moving, the view will also move accordingly.
   * If the view is dragged by the user, the focus is broken. You can supply options to customize the effect.
   *
   */
  focus(nodeId: IdType, options?: FocusOptions): void;

  /**
   * You can animate or move the camera using the moveTo method.
   *
   */
  moveTo(options: MoveToOptions): void;

  /**
   * Programatically release the focussed node.
   */
  releaseNode(): void;

  /**
   * If you use the configurator, you can call this method to get an options object that contains
   * all differences from the default options caused by users interacting with the configurator.
   *
   */
  getOptionsFromConfigurator(): any;
}

/**
 * Options interface for focus function.
 */
interface FocusOptions extends ViewPortOptions {
  /**
   * Locked denotes whether or not the view remains locked to
   * the node once the zoom-in animation is finished.
   * Default value is true.
   */
  locked?: boolean;
}

/**
 * Base options interface for some viewport functions.
 */
interface ViewPortOptions {
  /**
   * The scale is the target zoomlevel.
   * Default value is 1.0.
   */
  scale?: number;

  /**
   * The offset (in DOM units) is how many pixels from the center the view is focussed.
   * Default value is {x:0,y:0}
   */
  offset?: Position;

  /**
   * For animation you can either use a Boolean to use it with the default options or
   * disable it or you can define the duration (in milliseconds) and easing function manually.
   */
  animation?: AnimationOptions | boolean;
}

/**
 * You will have to define at least a scale, position or offset.
 * Otherwise, there is nothing to move to.
 */
interface MoveToOptions extends ViewPortOptions {
  /**
   * The position (in canvas units!) is the position of the central focus point of the camera.
   */
  position?: Position;
}

/**
 * Animation options interface.
 */
interface AnimationOptions {
  /**
   * The duration (in milliseconds).
   */
  duration: number;
  /**
   * The easing function.
   *
   * Available are:
   * linear, easeInQuad, easeOutQuad, easeInOutQuad, easeInCubic,
   * easeOutCubic, easeInOutCubic, easeInQuart, easeOutQuart, easeInOutQuart,
   * easeInQuint, easeOutQuint, easeInOutQuint.
   */
  easingFunction: EasingFunction;
}

type EasingFunction =
  'linear' |
  'easeInQuad' |
  'easeOutQuad' |
  'easeInOutQuad' |
  'easeInCubic' |
  'easeOutCubic' |
  'easeInOutCubic' |
  'easeInQuart' |
  'easeOutQuart' |
  'easeInOutQuart' |
  'easeInQuint' |
  'easeOutQuint' |
  'easeInOutQuint';

/**
 * Optional options for the fit method.
 */
interface FitOptions {
  /**
   * The nodes can be used to zoom to fit only specific nodes in the view.
   */
  nodes?: IdType[];

  /**
   * How far away can be zoomed out, the default is just above 0.
   *
   * @remarks
   * Values less than 1 mean zooming out, more than 1 means zooming in.
   */
  minZoomLevel?: number;

  /**
   * How close can be zoomed in, the default is 1.
   *
   * @remarks
   * Values less than 1 mean zooming out, more than 1 means zooming in.
   */
  maxZoomLevel?: number;

  /**
   * For animation you can either use a Boolean to use it with the default options or
   * disable it or you can define the duration (in milliseconds) and easing function manually.
   */
  animation?: TimelineAnimationType;
}

interface SelectionOptions {
  unselectAll?: boolean;
  highlightEdges?: boolean;
}

/**
 * These values are in canvas space.
 */
interface BoundingBox {
  top: number;
  left: number;
  right: number;
  bottom: number;
}

/**
 * Cluster methods options interface.
 */
interface ClusterOptions {
  /**
   * Optional for all but the cluster method.
   * The cluster module loops over all nodes that are selected to be in the cluster
   * and calls this function with their data as argument. If this function returns true,
   * this node will be added to the cluster. You have access to all options (including the default)
   * as well as any custom fields you may have added to the node to determine whether or not to include it in the cluster.
   */
  joinCondition?(nodeOptions: any): boolean;

  /**
   * Optional.
   * Before creating the new cluster node, this (optional) function will be called with the properties
   * supplied by you (clusterNodeProperties), all contained nodes and all contained edges.
   * You can use this to update the properties of the cluster based on which items it contains.
   * The function should return the properties to create the cluster node.
   */
  processProperties?(clusterOptions: any, childNodesOptions: any[], childEdgesOptions: any[]): any;

  /**
   * Optional.
   * This is an object containing the options for the cluster node.
   * All options described in the nodes module are allowed.
   * This allows you to style your cluster node any way you want.
   * This is also the style object that is provided in the processProperties function for fine tuning.
   * If undefined, default node options will be used.
   */
  clusterNodeProperties?: NodeOptions;

  /**
   * Optional.
   * This is an object containing the options for the edges connected to the cluster.
   * All options described in the edges module are allowed.
   * Using this, you can style the edges connecting to the cluster any way you want.
   * If none are provided, the options from the edges that are replaced are used.
   * If undefined, default edge options will be used.
   */
  clusterEdgeProperties?: EdgeOptions;
}

/**
 * Options for the openCluster function of Network.
 */
interface OpenClusterOptions {
  /**
   * A function that can be used to manually position the nodes after the cluster is opened.
   * The containedNodesPositions contain the positions of the nodes in the cluster at the
   * moment they were clustered. This function is expected to return the newPositions,
   * which can be the containedNodesPositions (altered) or a new object.
   * This has to be an object with keys equal to the nodeIds that exist in the
   * containedNodesPositions and an {x:x,y:y} position object.
   *
   * For all nodeIds not listed in this returned object,
   * we will position them at the location of the cluster.
   * This is also the default behaviour when no releaseFunction is defined.
   */
  releaseFunction(
    clusterPosition: Position,
    containedNodesPositions: { [nodeId: string]: Position }): { [nodeId: string]: Position };
}

interface Position {
  x: number;
  y: number;
}

interface Data$1 {
  nodes?: Node$1[] | DataInterfaceNodes;
  edges?: Edge[] | DataInterfaceEdges;
}

interface Node$1 extends NodeOptions {
  id?: IdType;
}

interface Edge extends EdgeOptions {
  from?: IdType;
  to?: IdType;
  id?: IdType;
}

interface Locales {
  [language: string]: LocaleMessages | undefined;
  en?: LocaleMessages;
  cn?: LocaleMessages;
  de?: LocaleMessages;
  es?: LocaleMessages;
  it?: LocaleMessages;
  nl?: LocaleMessages;
  'pt-br'?: LocaleMessages;
  ru?: LocaleMessages;
}

interface LocaleMessages {
  edit: string;
  del: string;
  back: string;
  addNode: string;
  addEdge: string;
  editNode: string;
  editEdge: string;
  addDescription: string;
  edgeDescription: string;
  editEdgeDescription: string;
  createEdgeError: string;
  deleteClusterError: string;
  editClusterError: string;
}

interface Options$4 {
  autoResize?: boolean;

  width?: string;

  height?: string;

  locale?: string;

  locales?: Locales;

  clickToUse?: boolean;

  configure?: any; // https://visjs.github.io/vis-network/docs/network/configure.html

  edges?: EdgeOptions;

  nodes?: NodeOptions;

  groups?: any;

  layout?: any; // https://visjs.github.io/vis-network/docs/network/layout.html

  interaction?: any; // https://visjs.github.io/vis-network/docs/network/interaction.html?keywords=edges

  manipulation?: any; // https://visjs.github.io/vis-network/docs/network/manipulation.html

  physics?: any; // https://visjs.github.io/vis-network/docs/network/physics.html
}

interface Image {
  unselected?: string;
  selected?: string;
}

interface ImagePadding {
  top?: number;
  right?: number;
  bottom?: number;
  left?: number;
}

interface Color {
  border?: string;

  background?: string;

  highlight?: string | {
    border?: string;
    background?: string;
  };

  hover?: string | {
    border?: string;
    background?: string;
  };
}

interface ChosenLabelValues {
  color: string;
  face: string;
  mod: string;
  size: number;
  strokeColor: string;
  strokeWidth: number;
  vadjust: number;
}
type NodeChosenLabelFunction = (
  values: ChosenLabelValues,
  id: IdType,
  selected: boolean,
  hovered: boolean
) => void;

interface ChosenNodeValues {
  borderColor: string;
  borderDashes: boolean | number[];
  borderRadius: number;
  borderWidth: number;
  color: string;
  shadow: boolean;
  shadowColor: string;
  shadowSize: number;
  shadowX: number;
  shadowY: number;
  size: number;
}
type NodeChosenNodeFunction = (
  values: ChosenNodeValues,
  id: IdType,
  selected: boolean,
  hovered: boolean
) => void;

interface NodeChosen {
  node: boolean | NodeChosenNodeFunction;
  label: boolean | NodeChosenLabelFunction;
}

interface NodeOptions {
  borderWidth?: number;

  borderWidthSelected?: number;

  brokenImage?: string;

  color?: string | Color;

  chosen?: boolean | NodeChosen;

  opacity?: number;

  fixed?: boolean | {
    x?: boolean,
    y?: boolean,
  };

  font?: string | Font;

  group?: string;

  hidden?: boolean;

  icon?: {
    face?: string,
    code?: string,
    size?: number,  // 50,
    color?: string,
    weight?: number | string,
  };

  image?: string | Image;

  imagePadding?: number | ImagePadding;

  label?: string;

  labelHighlightBold?: boolean;

  level?: number;

  margin?: {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };

  mass?: number;

  physics?: boolean;

  scaling?: OptionsScaling;

  shadow?: boolean | OptionsShadow;

  shape?: string;

  shapeProperties?: {
    borderDashes?: boolean | number[], // only for borders
    borderRadius?: number,     // only for box shape
    interpolation?: boolean,  // only for image and circularImage shapes
    useImageSize?: boolean,  // only for image and circularImage shapes
    useBorderWithImage?: boolean,  // only for image shape
    coordinateOrigin?: string  // only for image and circularImage shapes
  };

  size?: number;

  title?: string | HTMLElement;

  value?: number;

  /**
   * If false, no widthConstraint is applied. If a number is specified, the minimum and maximum widths of the node are set to the value.
   * The node's label's lines will be broken on spaces to stay below the maximum and the node's width
   * will be set to the minimum if less than the value.
   */
  widthConstraint?: number | boolean | { minimum?: number, maximum?: number };

  x?: number;

  y?: number;
}

interface EdgeOptions {
  arrows?: string | {
    to?: boolean | ArrowHead
    middle?: boolean | ArrowHead
    from?: boolean | ArrowHead
  };

  arrowStrikethrough?: boolean;

  chosen?: boolean | {
    edge?: boolean, // please note, chosen.edge could be also a function. This case is not represented here
    label?: boolean, // please note, chosen.label could be also a function. This case is not represented here
  };

  color?: string | {
    color?: string,
    highlight?: string,
    hover?: string,
    inherit?: boolean | string,
    opacity?: number,
  };

  dashes?: boolean | number[];

  font?: string | Font;

  hidden?: boolean;

  hoverWidth?: number; // please note, hoverWidth could be also a function. This case is not represented here

  label?: string;

  labelHighlightBold?: boolean;

  length?: number;

  physics?: boolean;

  scaling?: OptionsScaling;

  selectionWidth?: number; // please note, selectionWidth could be also a function. This case is not represented here

  selfReferenceSize?: number;

  selfReference?: {
    size?: number,
    angle?: number,
    renderBehindTheNode?: boolean
  };

  shadow?: boolean | OptionsShadow;

  smooth?: boolean | {
    enabled: boolean,
    type: string,
    forceDirection?: string | boolean,
    roundness: number,
  };

  title?: string | HTMLElement;

  value?: number;

  width?: number;

  widthConstraint?: number | boolean | {
    maximum?: number;
  };
}

interface ArrowHead {
  enabled?: boolean,
  imageHeight?: number,
  imageWidth?: number,
  scaleFactor?: number,
  src?: string,
  type?: string;
}

interface Font {
  color?: string,
  size?: number, // px
  face?: string,
  background?: string,
  strokeWidth?: number, // px
  strokeColor?: string,
  align?: string,
  vadjust?: number,
  multi?: boolean | string,
  bold?: string | FontStyles,
  ital?: string | FontStyles,
  boldital?: string | FontStyles,
  mono?: string | FontStyles,
}

interface FontStyles {
  color?: string;
  size?: number;
  face?: string;
  mod?: string;
  vadjust?: number;
}

interface OptionsScaling {
  min?: number;
  max?: number;
  label?: boolean | {
    enabled?: boolean,
    min?: number,
    max?: number,
    maxVisible?: number,
    drawThreshold?: number
  };
  customScalingFunction?(min?: number, max?: number, total?: number, value?: number): number;
}

interface OptionsShadow {
  enabled?: boolean;
  color?: string;
  size?: number;
  x?: number;
  y?: number;
}

export module 'keycharm' {
  interface KeycharmOptions {
    preventDefault?: boolean;
    container?: Window | Element;
  }

  type BindType = 'keydown' | 'keyup';

  interface Keycharm {
    bind(key: string, callback: (ev: KeyboardEvent) => void, type?: BindType): void;

    bindAll(callback: (ev: KeyboardEvent) => void, type?: BindType): void;

    unbind(key: string, callback?: (ev: KeyboardEvent) => void, type?: BindType): void;

    reset(): void;

    destroy(): void

    getKey(event: KeyboardEvent): string;
  }

  export default function keycharm(options?: KeycharmOptions): Keycharm;
}

/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
export class Subscription$1 implements SubscriptionLike {
    /** @nocollapse */
    static EMPTY: Subscription$1;
    /**
     * A flag to indicate whether this Subscription has already been unsubscribed.
     * @type {boolean}
     */
    closed: boolean;
    /** @internal */
    protected _parentOrParents: Subscription$1 | Subscription$1[];
    /** @internal */
    private _subscriptions;
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    constructor(unsubscribe?: () => void);
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    unsubscribe(): void;
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription. Can also be used to add a child subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * When a parent subscription is unsubscribed, any child subscriptions that were added to it are also unsubscribed.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    add(teardown: TeardownLogic): Subscription$1;
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    remove(subscription: Subscription$1): void;
}

/**
 * Note: This will add Symbol.observable globally for all TypeScript users,
 * however, we are no longer polyfilling Symbol.observable
 */
export global {
    interface SymbolConstructor {
        readonly observable: symbol;
    }
}
/** OPERATOR INTERFACES */
interface UnaryFunction<T, R> {
    (source: T): R;
}
interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {
}
/** SUBSCRIPTION INTERFACES */
interface Unsubscribable {
    unsubscribe(): void;
}
export type TeardownLogic = Unsubscribable | Function | void;
interface SubscriptionLike extends Unsubscribable {
    unsubscribe(): void;
    readonly closed: boolean;
}
export type SubscribableOrPromise<T> = Subscribable<T> | Subscribable<never> | PromiseLike<T> | InteropObservable<T>;
/** OBSERVABLE INTERFACES */
interface Subscribable<T> {
    subscribe(observer?: PartialObserver<T>): Unsubscribable;
    /** @deprecated Use an observer instead of a complete callback */
    subscribe(next: null | undefined, error: null | undefined, complete: () => void): Unsubscribable;
    /** @deprecated Use an observer instead of an error callback */
    subscribe(next: null | undefined, error: (error: any) => void, complete?: () => void): Unsubscribable;
    /** @deprecated Use an observer instead of a complete callback */
    subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Unsubscribable;
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Unsubscribable;
}
export type InteropObservable<T> = {
    [Symbol.observable]: () => Subscribable<T>;
};
/** OBSERVER INTERFACES */
interface NextObserver<T> {
    closed?: boolean;
    next: (value: T) => void;
    error?: (err: any) => void;
    complete?: () => void;
}
interface ErrorObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error: (err: any) => void;
    complete?: () => void;
}
interface CompletionObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error?: (err: any) => void;
    complete: () => void;
}
export type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;
interface Observer<T> {
    closed?: boolean;
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
}
/** SCHEDULER INTERFACES */
interface SchedulerLike {
    now(): number;
    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription$1;
}
interface SchedulerAction<T> extends Subscription$1 {
    schedule(state?: T, delay?: number): Subscription$1;
}

/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
export class Subscriber$1<T> extends Subscription$1 implements Observer<T> {
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     * @nocollapse
     */
    static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber$1<T>;
    /** @internal */ syncErrorValue: any;
    /** @internal */ syncErrorThrown: boolean;
    /** @internal */ syncErrorThrowable: boolean;
    protected isStopped: boolean;
    protected destination: PartialObserver<any> | Subscriber$1<any>;
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    next(value?: T): void;
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached `Error`. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    error(err?: any): void;
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    complete(): void;
    unsubscribe(): void;
    protected _next(value: T): void;
    protected _error(err: any): void;
    protected _complete(): void;
    /** @deprecated This is an internal implementation detail, do not use. */
    _unsubscribeAndRecycle(): Subscriber$1<T>;
}

interface Operator<T, R> {
    call(subscriber: Subscriber$1<R>, source: any): TeardownLogic;
}

/**
 * Decides at subscription time which Observable will actually be subscribed.
 *
 * <span class="informal">`If` statement for Observables.</span>
 *
 * `iif` accepts a condition function and two Observables. When
 * an Observable returned by the operator is subscribed, condition function will be called.
 * Based on what boolean it returns at that moment, consumer will subscribe either to
 * the first Observable (if condition was true) or to the second (if condition was false). Condition
 * function may also not return anything - in that case condition will be evaluated as false and
 * second Observable will be subscribed.
 *
 * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that
 * was left undefined, resulting stream will simply complete immediately. That allows you to, rather
 * than controlling which Observable will be subscribed, decide at runtime if consumer should have access
 * to given Observable or not.
 *
 * If you have more complex logic that requires decision between more than two Observables, {@link defer}
 * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}
 * and exists only for convenience and readability reasons.
 *
 *
 * ## Examples
 * ### Change at runtime which Observable will be subscribed
 * ```ts
 * import { iif, of } from 'rxjs';
 *
 * let subscribeToFirst;
 * const firstOrSecond = iif(
 *   () => subscribeToFirst,
 *   of('first'),
 *   of('second'),
 * );
 *
 * subscribeToFirst = true;
 * firstOrSecond.subscribe(value => console.log(value));
 *
 * // Logs:
 * // "first"
 *
 * subscribeToFirst = false;
 * firstOrSecond.subscribe(value => console.log(value));
 *
 * // Logs:
 * // "second"
 *
 * ```
 *
 * ### Control an access to an Observable
 * ```ts
 * let accessGranted;
 * const observableIfYouHaveAccess = iif(
 *   () => accessGranted,
 *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.
 * );
 *
 * accessGranted = true;
 * observableIfYouHaveAccess.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('The end'),
 * );
 *
 * // Logs:
 * // "It seems you have an access..."
 * // "The end"
 *
 * accessGranted = false;
 * observableIfYouHaveAccess.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('The end'),
 * );
 *
 * // Logs:
 * // "The end"
 * ```
 *
 * @see {@link defer}
 *
 * @param {function(): boolean} condition Condition which Observable should be chosen.
 * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.
 * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.
 * @return {Observable} Either first or second Observable, depending on condition.
 * @static true
 * @name iif
 * @owner Observable
*/
export function iif<T = never, F = never>(condition: () => boolean, trueResult?: SubscribableOrPromise<T>, falseResult?: SubscribableOrPromise<F>): Observable<T | F>;

/**
 * Creates an Observable that emits no items to the Observer and immediately
 * emits an error notification.
 *
 * <span class="informal">Just emits 'error', and nothing else.
 * </span>
 *
 * ![](throw.png)
 *
 * This static operator is useful for creating a simple Observable that only
 * emits the error notification. It can be used for composing with other
 * Observables, such as in a {@link mergeMap}.
 *
 * ## Examples
 * ### Emit the number 7, then emit an error
 * ```ts
 * import { throwError, concat, of } from 'rxjs';
 *
 * const result = concat(of(7), throwError(new Error('oops!')));
 * result.subscribe(x => console.log(x), e => console.error(e));
 *
 * // Logs:
 * // 7
 * // Error: oops!
 * ```
 *
 * ---
 *
 * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 2
 * ```ts
 * import { throwError, interval, of } from 'rxjs';
 * import { mergeMap } from 'rxjs/operators';
 *
 * interval(1000).pipe(
 *   mergeMap(x => x === 2
 *     ? throwError('Twos are bad')
 *     : of('a', 'b', 'c')
 *   ),
 * ).subscribe(x => console.log(x), e => console.error(e));
 *
 * // Logs:
 * // a
 * // b
 * // c
 * // a
 * // b
 * // c
 * // Twos are bad
 * ```
 *
 * @see {@link Observable}
 * @see {@link empty}
 * @see {@link never}
 * @see {@link of}
 *
 * @param {any} error The particular Error to pass to the error notification.
 * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
 * the emission of the error notification.
 * @return {Observable} An error Observable: emits only the error notification
 * using the given error argument.
 * @static true
 * @name throwError
 * @owner Observable
 */
export function throwError(error: any, scheduler?: SchedulerLike): Observable<never>;

/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
export class Observable<T> implements Subscribable<T> {
    /** Internal implementation detail, do not use directly. */
    _isScalar: boolean;
    /** @deprecated This is an internal implementation detail, do not use. */
    source: Observable<any>;
    /** @deprecated This is an internal implementation detail, do not use. */
    operator: Operator<any, T>;
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber$1<T>) => TeardownLogic);
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     * @nocollapse
     * @deprecated use new Observable() instead
     */
    static create: Function;
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    lift<R>(operator: Operator<T, R>): Observable<R>;
    subscribe(observer?: PartialObserver<T>): Subscription$1;
    /** @deprecated Use an observer instead of a complete callback */
    subscribe(next: null | undefined, error: null | undefined, complete: () => void): Subscription$1;
    /** @deprecated Use an observer instead of an error callback */
    subscribe(next: null | undefined, error: (error: any) => void, complete?: () => void): Subscription$1;
    /** @deprecated Use an observer instead of a complete callback */
    subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Subscription$1;
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription$1;
    /** @deprecated This is an internal implementation detail, do not use. */
    _trySubscribe(sink: Subscriber$1<T>): TeardownLogic;
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void>;
    /** @internal This is an internal implementation detail, do not use. */
    _subscribe(subscriber: Subscriber$1<any>): TeardownLogic;
    /**
     * @nocollapse
     * @deprecated In favor of iif creation function: import { iif } from 'rxjs';
     */
    static if: typeof iif;
    /**
     * @nocollapse
     * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';
     */
    static throw: typeof throwError;
    pipe(): Observable<T>;
    pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;
    pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;
    pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;
    pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;
    pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;
    pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;
    pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;
    pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;
    pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;
    pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;
    toPromise<T>(this: Observable<T>): Promise<T>;
    toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;
    toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;
}

/**
 * A Subject is a special type of Observable that allows values to be
 * multicasted to many Observers. Subjects are like EventEmitters.
 *
 * Every Subject is an Observable and an Observer. You can subscribe to a
 * Subject, and you can call next to feed values as well as error and complete.
 *
 * @class Subject<T>
 */
export class Subject<T> extends Observable<T> implements SubscriptionLike {
    observers: Observer<T>[];
    closed: boolean;
    isStopped: boolean;
    hasError: boolean;
    thrownError: any;
    constructor();
    /**@nocollapse
     * @deprecated use new Subject() instead
    */
    static create: Function;
    lift<R>(operator: Operator<T, R>): Observable<R>;
    next(value?: T): void;
    error(err: any): void;
    complete(): void;
    unsubscribe(): void;
    /** @deprecated This is an internal implementation detail, do not use. */
    _trySubscribe(subscriber: Subscriber$1<T>): TeardownLogic;
    /** @deprecated This is an internal implementation detail, do not use. */
    _subscribe(subscriber: Subscriber$1<T>): Subscription$1;
    /**
     * Creates a new Observable with this Subject as the source. You can do this
     * to create customize Observer-side logic of the Subject and conceal it from
     * code that uses the Observable.
     * @return {Observable} Observable that the Subject casts to
     */
    asObservable(): Observable<T>;
}

/**
 * @license Angular v12.0.1
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */


/**
 * Use in components with the `@Output` directive to emit custom events
 * synchronously or asynchronously, and register handlers for those events
 * by subscribing to an instance.
 *
 * @usageNotes
 *
 * Extends
 * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)
 * for Angular by adding the `emit()` method.
 *
 * In the following example, a component defines two output properties
 * that create event emitters. When the title is clicked, the emitter
 * emits an open or close event to toggle the current visibility state.
 *
 * ```html
 * @Component({
 *   selector: 'zippy',
 *   template: `
 *   <div class="zippy">
 *     <div (click)="toggle()">Toggle</div>
 *     <div [hidden]="!visible">
 *       <ng-content></ng-content>
 *     </div>
 *  </div>`})
 * export class Zippy {
 *   visible: boolean = true;
 *   @Output() open: EventEmitter<any> = new EventEmitter();
 *   @Output() close: EventEmitter<any> = new EventEmitter();
 *
 *   toggle() {
 *     this.visible = !this.visible;
 *     if (this.visible) {
 *       this.open.emit(null);
 *     } else {
 *       this.close.emit(null);
 *     }
 *   }
 * }
 * ```
 *
 * Access the event object with the `$event` argument passed to the output event
 * handler:
 *
 * ```html
 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
 * ```
 *
 * @see [Observables in Angular](guide/observables-in-angular)
 * @publicApi
 */
export interface EventEmitter<T> extends Subject<T> {
    /**
     * Creates an instance of this class that can
     * deliver events synchronously or asynchronously.
     *
     * @param [isAsync=false] When true, deliver events asynchronously.
     *
     */
    new (isAsync?: boolean): EventEmitter<T>;
    /**
     * Emits an event containing a given value.
     * @param value The value to emit.
     */
    emit(value?: T): void;
    /**
     * Registers handlers for events emitted by this instance.
     * @param next When supplied, a custom handler for emitted events.
     * @param error When supplied, a custom handler for an error notification from this emitter.
     * @param complete When supplied, a custom handler for a completion notification from this
     *     emitter.
     */
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription$1;
    /**
     * Registers handlers for events emitted by this instance.
     * @param observerOrNext When supplied, a custom handler for emitted events, or an observer
     *     object.
     * @param error When supplied, a custom handler for an error notification from this emitter.
     * @param complete When supplied, a custom handler for a completion notification from this
     *     emitter.
     */
    subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription$1;
}

/**
 * @publicApi
 */
export const EventEmitter: {
    new (isAsync?: boolean): EventEmitter<any>;
    new <T>(isAsync?: boolean): EventEmitter<T>;
    readonly prototype: EventEmitter<any>;
};

export class GlobalService {
    readonly DEFAULT_LINK_COLOR = "#3583ea";
    readonly DEFAULT_NODE_COLOR = "#a4b7fc";
    readonly SELECTED_NODE_COLOR = "#4ee44e";
    readonly ACTIVE_NODE_COLOR = "#ffcccb";
    readonly LOG_INTERESTS = false;
    pendingUpdatesNodes: {
        [id: string]: Partial<INode>;
    };
    pendingUpdatesEdges: {
        [id: string]: Partial<IEdge>;
    };
    readonly nodes: DataSet<INode, "id">;
    readonly edges: DataSet<IEdge, "id">;
    network: Network;
    defaultLatency: number;
    defaultLoss: number;
    contentStoreSize: number;
    latencySlowdown: number;
    busiestNode?: INode;
    busiestLink?: IEdge;
    private selectedNode?;
    private selectedEdge?;
    captureAll: boolean;
    selectedNodeChangeCallback: EventEmitter<INode | undefined>;
    consoleLog: EventEmitter<{
        type: string;
        msg: string;
    }>;
    private scheduledRouteRefresh;
    constructor();
    /** Update objects every animation frame */
    runAnimationFrame(): void;
    /** Initialize the network */
    createNetwork(container: HTMLElement): void;
    /** Compute static routes */
    private computeRoutes;
    /** Schedule a refresh of static routes */
    scheduleRouteRefresh(): void;
    getSelectedNode(): INode | undefined;
    selectNode(node?: INode): void;
    getSelectedEdge(): IEdge | undefined;
    selectEdge(edge?: IEdge): void;
    ensureInitialized(): void;
}

/** Interest retransmission policy options. */
interface RetxOptions {
    /**
     * Maximum number of retransmissions, excluding initial Interest.
     *
     * Default is 0, which disables retransmissions.
     */
    limit?: number;
    /**
     * Initial retx interval
     *
     * Default is 50% of InterestLifetime.
     */
    interval?: number;
    /**
     * Randomize retx interval within [1-randomize, 1+randomize].
     *
     * Suppose this is set to 0.1, an interval of 100ms would become [90ms, 110ms].
     * Default is 0.1.
     */
    randomize?: number;
    /**
     * Multiply retx interval by backoff factor after each retx.
     *
     * This number should be in range [1.0, 2.0].
     * Default is 1.0.
     */
    backoff?: number;
    /**
     * Maximum retx interval.
     *
     * Default is 90% of InterestLifetime.
     */
    max?: number;
}
/** A function to generate retx intervals. */
export type RetxGenerator = (interestLifetime: number) => Iterable<number>;
/**
 * Interest retransmission policy.
 *
 * A number is interpreted as the limit.
 * Set 0 to disable retransmissions.
 */
export type RetxPolicy = RetxOptions | RetxGenerator | number;

interface Decodable<R> {
    decodeFrom: (decoder: Decoder) => R;
}
/** TLV decoder. */
export class Decoder {
    private input;
    /** Determine whether end of input has been reached. */
    get eof(): boolean;
    private offset;
    constructor(input: Uint8Array);
    /** Read TLV structure. */
    read(): Decoder.Tlv;
    /** Read a Decodable object. */
    decode<R>(d: Decodable<R>): R;
    private readVarNum;
    private readType;
    private readLength;
    private skipValue;
}
export namespace Decoder {
    /** Types acceptable to Decoder.from(). */
    type Input = Decoder | Uint8Array;
    /** Test whether obj is Decoder.Input. */
    function isInput(obj: unknown): obj is Input;
    /** Construct from Decoder.Input, or return existing Decoder. */
    function from(obj: Input): Decoder;
    /** Decoded TLV. */
    interface Tlv {
        /** TLV-TYPE */
        readonly type: number;
        /** TLV-LENGTH */
        readonly length: number;
        /** TLV-VALUE */
        readonly value: Uint8Array;
        /** TLV buffer */
        readonly tlv: Uint8Array;
        /** sizeof tlv */
        readonly size: number;
        /** TLV as decoder */
        readonly decoder: Decoder;
        /** TLV-VALUE as decoder */
        readonly vd: Decoder;
        /** TLV-VALUE as non-negative integer */
        readonly nni: number;
        /** TLV-VALUE as UTF-8 string */
        readonly text: string;
        /** siblings before this TLV */
        readonly before: Uint8Array;
        /** siblings after this TLV */
        readonly after: Uint8Array;
    }
}

/**
 * An object that knows how to prepend itself to an Encoder.
 */
interface EncodableObj {
    encodeTo: (encoder: Encoder) => void;
}
/**
 * An encodable TLV structure.
 *
 * First item is a number for TLV-TYPE.
 * Optional second item could be OmitEmpty to omit the TLV if TLV-VALUE is empty.
 * Subsequent items are Encodables for TLV-VALUE.
 */
export type EncodableTlv = [number, ...any[]];
/**
 * An object acceptable to Encoder.encode().
 */
export type Encodable = Uint8Array | undefined | EncodableObj | EncodableTlv;
/** TLV encoder that accepts objects in reverse order. */
export class Encoder {
    private buf;
    private off;
    /** Return encoding output size. */
    get size(): number;
    /** Obtain encoding output. */
    get output(): Uint8Array;
    constructor(initSize?: number);
    /** Obtain part of encoding output. */
    slice(start?: number, length?: number): Uint8Array;
    /**
     * Make room to prepend an object.
     * @param sizeofObject object size.
     * @returns room to write object.
     */
    prependRoom(sizeofObject: number): Uint8Array;
    /** Prepend TLV-TYPE and TLV-LENGTH. */
    prependTypeLength(tlvType: number, tlvLength: number): void;
    /** Prepend TLV-VALUE. */
    prependValue(...tlvValue: Encodable[]): void;
    /**
     * Prepend TLV structure.
     * @param tlvType TLV-TYPE number.
     * @param omitEmpty omit TLV altogether if set to Encoder.OmitEmpty
     * @param tlvValue TLV-VALUE objects.
     */
    prependTlv(tlvType: number, omitEmpty?: typeof Encoder.OmitEmpty | Encodable, ...tlvValue: Encodable[]): void;
    /** Prepend an Encodable object. */
    encode(obj: Encodable | readonly Encodable[]): void;
    private grow;
}
export namespace Encoder {
    function asDataView(a: Uint8Array): DataView;
    const OmitEmpty: unique symbol;
    function encode(obj: Encodable | readonly Encodable[], initBufSize?: number): Uint8Array;
    /** Extract the encoding output of an element while writing to a larger encoder. */
    function extract(obj: Encodable | readonly Encodable[], cb: (output: Uint8Array) => void): Encodable;
}

/** Invoked when a matching TLV element is found. */
export type ElementCallback<T> = (target: T, tlv: Decoder.Tlv) => void;
interface Rule$1<T> {
    cb: ElementCallback<T>;
    /**
     * Expected order of appearance.
     * Default to the order in which rules were added to EvDecoder.
     */
    order: number;
    /** Whether TLV element must appear at least once. */
    required: boolean;
    /** Whether TLV element may appear more than once. */
    repeat: boolean;
}
export type RuleOptions<T> = Partial<Omit<Rule$1<T>, "cb">>;
/**
 * Invoked when a TLV element does not match any rule.
 * 'order' denotes the order number of last recognized TLV element.
 * Return true if this TLV element is accepted, or false to follow evolvability guidelines.
 */
export type UnknownElementCallback<T> = (target: T, tlv: Decoder.Tlv, order: number) => boolean;
export type IsCriticalCallback = (tt: number) => boolean;
export type TopElementCallback<T> = (target: T, tlv: Decoder.Tlv) => void;
export type TargetCallback<T> = (target: T) => void;
/** TLV-VALUE decoder that understands Packet Format v0.3 evolvability guidelines. */
export class EvDecoder<T> {
    private readonly typeName;
    private readonly topTT;
    private readonly rules;
    private readonly requiredTlvTypes;
    private nextOrder;
    private isCriticalCb;
    private unknownCb;
    /** Callbacks to receive top-level TLV before decoding TLV-VALUE. */
    readonly beforeTopCallbacks: TopElementCallback<T>[];
    /** Callbacks before decoding TLV-VALUE. */
    readonly beforeValueCallbacks: TargetCallback<T>[];
    /** Callbacks after decoding TLV-VALUE. */
    readonly afterValueCallbacks: TargetCallback<T>[];
    /** Callbacks to receive top-level TLV after decoding TLV-VALUE. */
    readonly afterTopCallbacks: TopElementCallback<T>[];
    /**
     * Constructor.
     * @param typeName type name, used in error messages.
     * @param topTT if specified, check top-level TLV-TYPE to be in this list.
     */
    constructor(typeName: string, topTT?: number | readonly number[]);
    /**
     * Add a decoding rule.
     * @param tt TLV-TYPE to match this rule.
     * @param cb callback to handle element TLV.
     * @param options additional rule options.
     */
    add(tt: number, cb: ElementCallback<T> | EvDecoder<T>, options?: RuleOptions<T>): this;
    /** Set callback to determine whether TLV-TYPE is critical. */
    setIsCritical(cb: IsCriticalCallback): this;
    /** Set callback to handle unknown elements. */
    setUnknown(cb: UnknownElementCallback<T>): this;
    /** Decode TLV to target object. */
    decode<R extends T = T>(target: R, decoder: Decoder): R;
    /** Decode TLV-VALUE to target object. */
    decodeValue<R extends T = T>(target: R, vd: Decoder): R;
    private handleUnrecognized;
}

/** An TLV element that allows extension sub element. */
interface Extensible {
    [Extensible.TAG]: Extensible.Records;
}
export namespace Extensible {
    const TAG: unique symbol;
    type Records = Map<number, unknown>;
    function newRecords(): Map<number, unknown>;
}
/**
 * An extension sub element on a parent TLV element.
 * T is the parent TLV element type.
 * R is the value type of this extension.
 */
interface Extension<T, R = unknown> {
    /** TLV-TYPE. */
    readonly tt: number;
    /** Order relative to other extensions, used on encoding only. */
    readonly order?: number;
    /**
     * Decode extension element.
     * @param obj parent object.
     * @param tlv TLV of sub element; its TLV-TYPE would be this.tt .
     * @param accumulator previous decoded value, if extension element appears more than once.
     */
    decode: (obj: T, tlv: Decoder.Tlv, accumulator?: R) => R;
    /**
     * Encode extension element.
     * @param obj parent object.
     * @param value decoded value.
     * @returns encoding of sub element; its TLV-TYPE should be this.tt .
     */
    encode: (obj: T, value: R) => Encodable;
}
export namespace Extension {
    function get(obj: Extensible, tt: number): unknown;
    function set(obj: Extensible, tt: number, value: unknown): void;
    function clear(obj: Extensible, tt: number): void;
}
export class ExtensionRegistry<T extends Extensible> {
    private table;
    registerExtension: <R>(ext: Extension<T, R>) => void;
    unregisterExtension: (tt: number) => void;
    decodeUnknown: (target: T, tlv: Decoder.Tlv, order: number) => boolean;
    encode(source: T): Encodable[];
}

export class Nni1 {
    private readonly n;
    constructor(n: number);
    encodeTo(encoder: Encoder): void;
}
export class Nni2 {
    private readonly n;
    constructor(n: number);
    encodeTo(encoder: Encoder): void;
}
export class Nni4 {
    private readonly n;
    constructor(n: number);
    encodeTo(encoder: Encoder): void;
}
export class Nni8Number {
    private readonly n;
    constructor(n: number);
    encodeTo(encoder: Encoder): void;
}
export type Len = 1 | 2 | 4 | 8;
interface Options$3<LenT = Len> {
    /** If set, use/enforce specific TLV-LENGTH. */
    len?: LenT;
    /** If true, allow approximate integers. */
    unsafe?: boolean;
}
export const EncodeNniClass: {
    1: typeof Nni1;
    2: typeof Nni2;
    4: typeof Nni4;
    8: typeof Nni8Number;
};
/** Create Encodable from non-negative integer. */
export function NNI(n: number | bigint, { len, unsafe, }?: Options$3<Extract<Len, keyof typeof EncodeNniClass>>): Encodable;
export namespace NNI {
    /** Determine if len is a valid length of encoded NNI. */
    function isValidLength(len: number): boolean;
    /** Decode non-negative integer as number. */
    function decode(value: Uint8Array, opts?: Options$3 & {
        big?: false;
    }): number;
    /** Decode non-negative integer as bigint. */
    function decode(value: Uint8Array, opts: Options$3 & {
        big: true;
    }): bigint;
    /** Error if n exceeds [0,MAX_SAFE_INTEGER] range. */
    function constrain(n: number, typeName: string): number;
    /** Error if n exceeds [0,max] range. */
    function constrain(n: number, typeName: string, max: number): number;
    /** Error if n exceeds [min,max] range. */
    function constrain(n: number, typeName: string, min: number, max?: number): number;
}

/** Pretty-print TLV-TYPE number. */
export function printTT(tlvType: number): string;
/** Convert byte array to upper-case hexadecimal string. */
export function toHex(buf: Uint8Array): string;
/**
 * Convert hexadecimal string to byte array.
 *
 * This function lacks error handling. Use on trusted input only.
 */
export function fromHex(s: string): Uint8Array;
export function toUtf8(s: string): Uint8Array;
export function fromUtf8(buf: Uint8Array): string;

type tlv_Decodable<_0> = Decodable<_0>;
export const tlv_Decoder: typeof Decoder;
type tlv_EncodableObj = EncodableObj;
type tlv_EncodableTlv = EncodableTlv;
type tlv_Encodable = Encodable;
export const tlv_Encoder: typeof Encoder;
type tlv_EvDecoder<_0> = EvDecoder<_0>;
export const tlv_EvDecoder: typeof EvDecoder;
export const tlv_Extensible: typeof Extensible;
export const tlv_Extension: typeof Extension;
type tlv_ExtensionRegistry<_0> = ExtensionRegistry<_0>;
export const tlv_ExtensionRegistry: typeof ExtensionRegistry;
export const tlv_NNI: typeof NNI;
export const tlv_printTT: typeof printTT;
export const tlv_toHex: typeof toHex;
export const tlv_fromHex: typeof fromHex;
export const tlv_toUtf8: typeof toUtf8;
export const tlv_fromUtf8: typeof fromUtf8;
export namespace tlv {
  export {
    tlv_Decodable as Decodable,
    tlv_Decoder as Decoder,
    tlv_EncodableObj as EncodableObj,
    tlv_EncodableTlv as EncodableTlv,
    tlv_Encodable as Encodable,
    tlv_Encoder as Encoder,
    tlv_EvDecoder as EvDecoder,
    tlv_Extensible as Extensible,
    tlv_Extension as Extension,
    tlv_ExtensionRegistry as ExtensionRegistry,
    tlv_NNI as NNI,
    tlv_printTT as printTT,
    tlv_toHex as toHex,
    tlv_fromHex as fromHex,
    tlv_toUtf8 as toUtf8,
    tlv_fromUtf8 as fromUtf8,
  };
}

/**
 * Naming convention, which interprets a name component in a specific way.
 * @template A input type to construct component.
 * @template R output type to interpret component.
 */
interface NamingConvention<A, R = A> {
    /** Determine if a component follows this naming convention. */
    match: (comp: Component) => boolean;
    /** Create a component from input value following this naming convention. */
    create: (v: A) => Component;
    /** Parse value of a matched component. */
    parse: (comp: Component) => R;
}
export namespace NamingConvention {
    /** A naming convention that supports alternate/pretty URI. */
    interface WithAltUri {
        /** Convert to alternate URI. */
        toAltUri: (comp: Component) => string;
        /**
         * Parse from alternate URI.
         * @returns component, or undefined if it cannot be parsed.
         */
        fromAltUri: (input: string) => Component | undefined;
    }
    function isConvention(obj: any): obj is NamingConvention<any>;
}

export type ComponentLike = Component | string;
/**
 * Name component.
 * This type is immutable.
 */
export class Component {
    get length(): number;
    /** TLV-VALUE interpreted as UTF-8 string. */
    get text(): string;
    static decodeFrom(decoder: Decoder): Component;
    /** Parse from URI representation, or return existing Component. */
    static from(input: ComponentLike): Component;
    readonly tlv: Uint8Array;
    readonly type: number;
    readonly value: Uint8Array;
    /**
     * Construct from TLV-TYPE and TLV-VALUE.
     * @param type TLV-TYPE, default is GenericNameComponent.
     * @param value TLV-VALUE; if specified as string, it's encoded as UTF-8 but not interpreted
     *              as URI representation. Use from() to interpret URI.
     */
    constructor(type?: number, value?: Uint8Array | string);
    /** Construct from TLV. */
    constructor(tlv: Uint8Array);
    /** Get URI string. */
    toString(): string;
    encodeTo(encoder: Encoder): void;
    /** Determine if component follows a naming convention. */
    is(convention: NamingConvention<any>): boolean;
    /** Convert with naming convention. */
    as<R>(convention: NamingConvention<any, R>): R;
    /** Compare this component with other. */
    compare(other: ComponentLike): Component.CompareResult;
    /** Determine if this component equals other. */
    equals(other: ComponentLike): boolean;
}
export namespace Component {
    /** Component compare result. */
    enum CompareResult {
        /** lhs is less than rhs */
        LT = -2,
        /** lhs and rhs are equal */
        EQUAL = 0,
        /** lhs is greater than rhs */
        GT = 2
    }
    /** Compare two components. */
    function compare(lhs: ComponentLike, rhs: ComponentLike): CompareResult;
}

export type NameLike = Name | string;
/**
 * Name.
 * This type is immutable.
 */
export class Name {
    static decodeFrom(decoder: Decoder): Name;
    /** TLV-VALUE of the Name. */
    readonly value: Uint8Array;
    /** List of name components. */
    readonly comps: readonly Component[];
    /** Create empty name, or copy from other name, or parse from URI. */
    constructor(input?: NameLike);
    /** Parse from URI, with specific component parser. */
    constructor(uri: string, parseComponent?: (input: string) => Component);
    /** Construct from TLV-VALUE. */
    constructor(value: Uint8Array);
    /** Construct from components. */
    constructor(comps: readonly ComponentLike[]);
    get length(): number;
    /** Retrieve i-th component. */
    get(i: number): Component | undefined;
    /**
     * Retrieve i-th component.
     * @throws i-th component does not exist.
     */
    at(i: number): Component;
    /** Get URI string. */
    toString(): string;
    /** Get sub name [begin, end). */
    slice(begin?: number, end?: number): Name;
    /** Get prefix of n components. */
    getPrefix(n: number): Name;
    /** Append a component from naming convention. */
    append<A>(convention: NamingConvention<A, unknown>, v: A): Name;
    /** Append suffix with one or more components. */
    append(...suffix: readonly ComponentLike[]): Name;
    /** Return a copy of Name with a component replaced. */
    replaceAt(i: number, comp: ComponentLike): Name;
    /** Compare with other name. */
    compare(other: NameLike): Name.CompareResult;
    /** Determine if this name equals other. */
    equals(other: NameLike): boolean;
    /** Determine if this name is a prefix of other. */
    isPrefixOf(other: NameLike): boolean;
    encodeTo(encoder: Encoder): void;
}
export namespace Name {
    function isNameLike(obj: any): obj is NameLike;
    /** Name compare result. */
    enum CompareResult {
        /** lhs is less than, but not a prefix of rhs */
        LT = -2,
        /** lhs is a prefix of rhs */
        LPREFIX = -1,
        /** lhs and rhs are equal */
        EQUAL = 0,
        /** rhs is a prefix of lhs */
        RPREFIX = 1,
        /** rhs is less than, but not a prefix of lhs */
        GT = 2
    }
}

/**
 * Name longest prefix match algorithm.
 * @param name target name.
 * @param get callback function to retrieve entry by hexadecimal name prefix.
 */
export function lpm<Entry>(name: Name, get: (prefixHex: string) => Entry | undefined): Entry | undefined;

/**
 * Functions to print and parse names in alternate/pretty URI syntax.
 *
 * This class is constructed with a sequence of NamingConventions. Each component is matched
 * against these conventions in order, and the first matching convention can determine how to
 * print that component in an alternate URI syntax, if available.
 *
 * Other than pre-constructed 'AltUri' instances exported by this and naming convention packages,
 * you may construct an instance with only the naming conventions you have adopted, so that a
 * component that happens to match a convention that your application did not adopt is not
 * mistakenly interpreted with that convention.
 */
export class AltUriConverter {
    readonly conventions: ReadonlyArray<NamingConvention<any> & NamingConvention.WithAltUri>;
    constructor(conventions: ReadonlyArray<NamingConvention<any> & NamingConvention.WithAltUri>);
    /** Print component in alternate URI syntax */
    ofComponent: (comp: Component) => string;
    /** Print name in alternate URI syntax. */
    ofName: (name: Name) => string;
    /** Parse component from alternate URI syntax */
    parseComponent: (input: string) => Component;
    /** Parse name from alternate URI syntax. */
    parseName: (input: string) => Name;
}
/** Print Generic, ImplicitDigest, ParamsDigest in alternate URI syntax. */
export const AltUri: AltUriConverter;

export class DigestComp implements NamingConvention<Uint8Array>, NamingConvention.WithAltUri {
    private readonly tt;
    private readonly altUriPrefix;
    private readonly altUriRegex;
    constructor(tt: number, altUriPrefix: string);
    match(comp: Component): boolean;
    create(v: Uint8Array): Component;
    parse(comp: Component): Uint8Array;
    toAltUri(comp: Component): string;
    fromAltUri(input: string): Component | undefined;
}
export class ImplicitDigestComp extends DigestComp {
    constructor();
    /** Remove ImplicitDigest if present at last component. */
    strip(name: Name): Name;
}
/** ImplicitSha256DigestComponent */
export const ImplicitDigest: ImplicitDigestComp;
export class ParamsDigestComp extends DigestComp {
    /** ParamsDigest placeholder during Interest encoding. */
    readonly PLACEHOLDER: Component;
    constructor();
    /** Determine if comp is a ParamsDigest placeholder. */
    isPlaceholder(comp: Component): boolean;
    /** Find ParamsDigest or placeholder in name. */
    findIn(name: Name, matchPlaceholder?: boolean): number;
}
/** ParametersSha256DigestComponent */
export const ParamsDigest: ParamsDigestComp;

/** ForwardingHint in Interest. */
export class FwHint {
    static decodeValue(value: Uint8Array): FwHint;
    constructor(copy?: FwHint);
    constructor(delegations: readonly FwHint.Delegation[]);
    get delegations(): readonly FwHint.Delegation[];
    private readonly m;
    encodeTo(encoder: Encoder): void;
}
export namespace FwHint {
    /** Delegation in ForwardingHint. */
    class Delegation {
        preference: number;
        static decodeFrom(decoder: Decoder): Delegation;
        constructor(name?: NameLike, preference?: number);
        name: Name;
        encodeTo(encoder: Encoder): void;
    }
}

/** KeyLocator in SigInfo. */
export class KeyLocator {
    static decodeFrom(decoder: Decoder): KeyLocator;
    name?: Name;
    digest?: Uint8Array;
    constructor(...args: KeyLocator.CtorArg[]);
    encodeTo(encoder: Encoder): void;
}
export namespace KeyLocator {
    type CtorArg = KeyLocator | NameLike | Uint8Array;
    function isCtorArg(arg: unknown): arg is CtorArg;
    /** Throw if KeyLocator is missing or does not have Name. */
    function mustGetName(kl?: KeyLocator): Name;
}

export const ctorAssign$2: unique symbol;
interface CtorTag$2 {
    [ctorAssign$2]: (si: SigInfo) => void;
}
/** SignatureInfo on Interest or Data. */
export class SigInfo {
    static decodeFrom(decoder: Decoder): SigInfo;
    type: number;
    keyLocator?: KeyLocator;
    nonce?: Uint8Array;
    time?: number;
    seqNum?: number;
    [Extensible.TAG]: Map<number, unknown>;
    /**
     * Construct from flexible arguments.
     *
     * Arguments can include, in any order:
     * - SigInfo to copy from
     * - number as SigType
     * - KeyLocator, or Name/URI/KeyDigest to construct KeyLocator
     * - SigInfo.Nonce(v)
     * - SigInfo.Time(v)
     * - SigInfo.SeqNum(v)
     */
    constructor(...args: SigInfo.CtorArg[]);
    /**
     * Create an Encodable.
     * @param tt either TT.ISigInfo or TT.DSigInfo.
     */
    encodeAs(tt: number): EncodableObj;
    private encodeTo;
}
export namespace SigInfo {
    function Nonce(v?: Uint8Array | number): CtorTag$2;
    /** Generate a random nonce. */
    function generateNonce(size?: number): Uint8Array;
    function Time(v?: number): CtorTag$2;
    function SeqNum(v: number): {
        [ctorAssign$2](si: SigInfo): void;
    };
    type CtorArg = SigInfo | number | KeyLocator.CtorArg | CtorTag$2;
    const registerExtension: <R>(ext: Extension<SigInfo, R>) => void;
    const unregisterExtension: (tt: number) => void;
}

export function timingSafeEqual(a: Uint8Array, b: Uint8Array): boolean;

/**
 * Low level signing function.
 * It takes a buffer of signed portion, and returns a Promise of signature value.
 */
export type LLSign = (input: Uint8Array) => Promise<Uint8Array>;
export namespace LLSign {
    const OP: unique symbol;
    interface Signable {
        [OP]: (signer: LLSign) => Promise<void>;
    }
}
/**
 * Low level verification function.
 * It takes a buffer of signed portion and the signature value, and returns a Promise
 * that is resolved upon good signature or rejected upon bad signature.
 */
export type LLVerify = (input: Uint8Array, sig: Uint8Array) => Promise<void>;
export namespace LLVerify {
    const OP: unique symbol;
    interface Verifiable {
        [OP]: (verifier: LLVerify) => Promise<void>;
    }
    const timingSafeEqual: typeof timingSafeEqual;
}
interface PacketWithSignature {
    readonly name: Name;
    sigInfo?: SigInfo;
    sigValue: Uint8Array;
}
/** High level signer, such as a private key. */
interface Signer {
    /** Sign a packet. */
    sign: (pkt: Signer.Signable) => Promise<void>;
}
export namespace Signer {
    interface Signable extends PacketWithSignature, LLSign.Signable {
    }
    /**
     * Put SigInfo on packet if it does not exist.
     * @param pkt target packet.
     * @param sigType optionally set sigType.
     * @param keyLocator optionally set keyLocator; false to unset KeyLocator.
     */
    function putSigInfo(pkt: PacketWithSignature, sigType?: number, keyLocator?: KeyLocator.CtorArg | false): SigInfo;
}
/** High level verifier, such as a public key. */
interface Verifier {
    /**
     * Verify a packet.
     * @returns a Promise is resolved upon good signature/policy or rejected upon bad signature/policy.
     */
    verify: (pkt: Verifier.Verifiable) => Promise<void>;
}
export namespace Verifier {
    interface Verifiable extends Readonly<PacketWithSignature>, LLVerify.Verifiable {
    }
    /** Throw if packet does not have expected SigType. */
    function checkSigType(pkt: Readonly<PacketWithSignature>, expectedSigType: number): void;
    /** Throw bad signature error if not OK. */
    function throwOnBadSig(ok: boolean): asserts ok;
}
/** Signer and Verifier that do nothing. */
export const noopSigning: Signer & Verifier;
/** Signer and Verifier for SigType.Sha256 digest. */
export const digestSigning: Signer & Verifier;
/**
 * Signer for SigType.Null, a packet that is not signed.
 * @see https://redmine.named-data.net/projects/ndn-tlv/wiki/NullSignature
 */
export const nullSigner: Signer;

export const FIELDS$1: unique symbol;
export class Fields$1 {
    constructor(...args: Array<Interest | Interest.CtorArg>);
    name: Name;
    canBePrefix: boolean;
    mustBeFresh: boolean;
    fwHint?: FwHint;
    get nonce(): number | undefined;
    set nonce(v: number | undefined);
    get lifetime(): number;
    set lifetime(v: number);
    get hopLimit(): number;
    set hopLimit(v: number);
    appParameters?: Uint8Array;
    sigInfo?: SigInfo;
    sigValue: Uint8Array;
    private nonce_;
    private lifetime_;
    private hopLimit_;
    signedPortion?: Uint8Array;
    paramsPortion?: Uint8Array;
}
export const ctorAssign$1: unique symbol;
interface CtorTag$1 {
    [ctorAssign$1]: (f: Fields$1) => void;
}
/** Interest packet. */
export class Interest implements LLSign.Signable, LLVerify.Verifiable, Signer.Signable, Verifier.Verifiable {
    /**
     * Construct from flexible arguments.
     *
     * Arguments can include, in any order:
     * - Interest to copy from
     * - Name or name URI
     * - Interest.CanBePrefix
     * - Interest.MustBeFresh
     * - Interest.Nonce(v)
     * - Interest.Lifetime(v)
     * - Interest.HopLimit(v)
     * - Uint8Array as AppParameters
     */
    constructor(...args: Array<Interest | Interest.CtorArg>);
    readonly [FIELDS$1]: Fields$1;
    static decodeFrom(decoder: Decoder): Interest;
    encodeTo(encoder: Encoder): void;
    private encodeParamsPortion;
    private appendParamsDigestPlaceholder;
    updateParamsDigest(): Promise<void>;
    validateParamsDigest(): Promise<void>;
    [LLSign.OP](sign: LLSign): Promise<void>;
    [LLVerify.OP](verify: LLVerify): Promise<void>;
}
interface Interest extends Fields$1 {
}
export namespace Interest {
    /** Signer that calculates ParamsDigest. */
    const Parameterize: LLSign;
    /** Generate a random nonce. */
    function generateNonce(): number;
    /** Default InterestLifetime. */
    const DefaultLifetime = 4000;
    /** Constructor argument to set CanBePrefix flag. */
    const CanBePrefix: unique symbol;
    /** Constructor argument to set MustBeFresh flag. */
    const MustBeFresh: unique symbol;
    /** Constructor argument to set Nonce field. */
    function Nonce(v?: number): CtorTag$1;
    /** Constructor argument to set InterestLifetime field. */
    function Lifetime(v: number): CtorTag$1;
    /** Constructor argument to set HopLimit field. */
    function HopLimit(v: number): CtorTag$1;
    /** Constructor argument. */
    type CtorArg = NameLike | typeof CanBePrefix | typeof MustBeFresh | FwHint | CtorTag$1 | Uint8Array;
    /** A function to modify an existing Interest. */
    type ModifyFunc = (interest: Interest) => void;
    /** Common fields to assign onto an existing Interest. */
    interface ModifyFields {
        canBePrefix?: boolean;
        mustBeFresh?: boolean;
        fwHint?: FwHint;
        lifetime?: number;
        hopLimit?: number;
    }
    /** A structure to modify an existing Interest. */
    type Modify = ModifyFunc | ModifyFields;
    /** Turn ModifyFields to ModifyFunc; return ModifyFunc as-is. */
    function makeModifyFunc(input?: Modify): ModifyFunc;
}

export const FIELDS: unique symbol;
export class Fields {
    constructor(...args: Array<Data | Data.CtorArg>);
    get isFinalBlock(): boolean;
    set isFinalBlock(v: boolean);
    name: Name;
    get contentType(): number;
    set contentType(v: number);
    get freshnessPeriod(): number;
    set freshnessPeriod(v: number);
    finalBlockId?: Component;
    content: Uint8Array;
    sigInfo: SigInfo;
    sigValue: Uint8Array;
    private contentType_;
    private freshnessPeriod_;
    signedPortion?: Uint8Array;
    topTlv?: Uint8Array;
    topTlvDigest?: Uint8Array;
}
export const ctorAssign: unique symbol;
interface CtorTag {
    [ctorAssign]: (f: Fields) => void;
}
/** Data packet. */
export class Data implements LLSign.Signable, LLVerify.Verifiable, Signer.Signable, Verifier.Verifiable {
    /**
     * Construct from flexible arguments.
     *
     * Arguments can include:
     * - Data to copy from
     * - Name or name URI
     * - Data.ContentType(v)
     * - Data.FreshnessPeriod(v)
     * - Data.FinalBlock (must appear after Name)
     * - Uint8Array as Content
     */
    constructor(...args: Array<Data | Data.CtorArg>);
    readonly [FIELDS]: Fields;
    static decodeFrom(decoder: Decoder): Data;
    encodeTo(encoder: Encoder): void;
    private encodeSignedPortion;
    getImplicitDigest(): Uint8Array | undefined;
    computeImplicitDigest(): Promise<Uint8Array>;
    getFullName(): Name | undefined;
    computeFullName(): Promise<Name>;
    /**
     * Determine if a Data can satisfy an Interest.
     * @returns a Promise that will be resolved with the result.
     */
    canSatisfy(interest: Interest): Promise<boolean>;
    [LLSign.OP](sign: LLSign): Promise<void>;
    [LLVerify.OP](verify: LLVerify): Promise<void>;
}
interface Data extends Fields {
}
export namespace Data {
    /** Constructor argument to set ContentType field. */
    function ContentType(v: number): CtorTag;
    /** Constructor argument to set FreshnessPeriod field. */
    function FreshnessPeriod(v: number): CtorTag;
    /** Constructor argument to set the current packet as FinalBlock. */
    const FinalBlock: unique symbol;
    /** Constructor argument. */
    type CtorArg = NameLike | CtorTag | typeof FinalBlock | Uint8Array;
}

/** Low level encryption function. */
export type LLEncrypt = (params: LLEncrypt.Params) => Promise<LLEncrypt.Result>;
export namespace LLEncrypt {
    /** Input of LLEncrypt function. */
    interface Params {
        plaintext: Uint8Array;
        iv?: Uint8Array;
        additionalData?: Uint8Array;
    }
    /** Output of LLEncrypt function. */
    interface Result {
        ciphertext: Uint8Array;
        iv?: Uint8Array;
        authenticationTag?: Uint8Array;
    }
    /** Object that provides LLEncrypt function, such as secret key. */
    interface Key {
        readonly llEncrypt: LLEncrypt;
    }
}
/** Low level decryption function. */
export type LLDecrypt = (params: LLDecrypt.Params) => Promise<LLDecrypt.Result>;
export namespace LLDecrypt {
    /** Input of LLDecrypt function. */
    interface Params {
        ciphertext: Uint8Array;
        iv?: Uint8Array;
        authenticationTag?: Uint8Array;
        additionalData?: Uint8Array;
    }
    /** Output of LLDecrypt function. */
    interface Result {
        plaintext: Uint8Array;
    }
    /** Object that provides LLDecrypt function, such as secret key. */
    interface Key {
        readonly llDecrypt: LLDecrypt;
    }
}
/**
 * High level encrypter.
 *
 * This captures both the encryption key and the wire format of encrypted content.
 */
interface Encrypter<T = Data> {
    /** Encrypt a packet. The packet is modified in-place. */
    encrypt: (pkt: T) => Promise<void>;
}
/**
 * High level decrypter.
 *
 * This captures both the decryption key and the wire format of encrypted content.
 */
interface Decrypter<T = Data> {
    /** Decrypt a packet. The packet is modified in-place. */
    decrypt: (pkt: T) => Promise<void>;
}
/** Encrypter and decrypter that do nothing. */
export const noopEncryption: Encrypter<any> & Decrypter<any>;

interface KeyState {
    nonces?: Set<string>;
    time?: number;
    seqNum?: number;
}
interface Rule {
    update: (si: SigInfo, state: KeyState) => void;
    check: (si: SigInfo, state: KeyState) => () => void;
}
/** Validation policy for SigInfo fields in signed Interest. */
export class SignedInterestPolicy {
    private readonly owned;
    private readonly trackedKeys;
    private readonly records;
    private readonly rules;
    /**
     * Constructor.
     * @param opts options.
     * @param rules one or more rules created from SignedInterestPolicy.Nonce(),
     *              SignedInterestPolicy.Time(), SignedInterestPolicy.SeqNum().
     */
    constructor(opts: SignedInterestPolicy.Options, ...rules: Rule[]);
    constructor(...rules: Rule[]);
    /**
     * Assign SigInfo fields on an Interest before signing.
     * @param key signing key object to associate state with; if omitted, use global state.
     */
    update(interest: Interest, key?: object): void;
    /**
     * Check SigInfo of an Interest.
     * @returns a function to save state after the Interest has passed all verifications.
     */
    check({ sigInfo }: Interest): () => void;
    /**
     * Wrap an Interest to update/check SigInfo during signing/verification.
     * During signing, global state is being used because signer key cannot be detected.
     */
    wrapInterest(interest: Interest): Signer.Signable & Verifier.Verifiable;
    /**
     * Wrap a Signer to update SigInfo when signing an Interest.
     * State is associated with the provided Signer.
     */
    makeSigner(inner: Signer): Signer;
    /** Wrap a Verifier to check the policy when verifying an Interest. */
    makeVerifier(inner: Verifier, { passData, passUnsignedInterest, }?: SignedInterestPolicy.WrapOptions): Verifier;
}
export namespace SignedInterestPolicy {
    interface Options {
        /**
         * How many distinct public keys to keep track.
         * Each different KeyLocator Name or KeyDigest is tracked separately.
         *
         * Minimum is 1.
         * @default 256
         */
        trackedKeys?: number;
    }
    interface WrapOptions {
        /**
         * If true, non-Interest packets are passed through to the inner Verifier.
         * If false, non-Interest packets are rejected.
         * @default true
         */
        passData?: boolean;
        /**
         * If true, Interests without SigInfo are passed through to the inner Verifier.
         * If false, Interests without SigInfo are rejected.
         * @default false
         */
        passUnsignedInterest?: boolean;
    }
    interface NonceOptions {
        /**
         * Length of generated SigNonce.
         *
         * Minimum is 1.
         * @default 8
         */
        nonceLength?: number;
        /**
         * Minimum required length of SigNonce.
         *
         * Minimum is 1.
         * @default 8
         */
        minNonceLength?: number;
        /**
         * How many distinct SigNonce values to keep track, within each public key.
         *
         * Minimum is 1.
         * @default 256
         */
        trackedNonces?: number;
    }
    /**
     * Create a rule to assign or check SigNonce.
     *
     * This rule assigns a random SigNonce of `minNonceLength` octets that does not duplicate
     * last `trackedNonces` values.
     *
     * This rule rejects an Interest on any of these conditions:
     * - SigNonce is absent.
     * - SigNonce has fewer than `minNonceLength` octets.
     * - SigNonce value duplicates any of last `trackedNonces` values.
     */
    function Nonce(opts?: NonceOptions): Rule;
    interface TimeOptions {
        /**
         * Maximum allowed clock offset in milliseconds.
         *
         * Minimum is 0. Setting to 0 is generally a bad idea because it would require consumer and
         * producer to have precisely synchronized clocks.
         * @default 60000
         */
        maxClockOffset?: number;
    }
    /**
     * Create a rule to assign or check SigTime.
     *
     * This rule assigns SigTime to be same as current timestamp, but may increment if it
     * duplicates the previous value.
     *
     * This rule rejects an Interest on any of these conditions:
     * - SigTime is absent.
     * - SigTime differs from current timestamp by more than `maxClockOffset` milliseconds.
     * - SigTime value is less than or equal to a previous value.
     *
     * This check logic differs from NDN Packet Format v0.3 specification (as of 2020-September) in
     * that `maxClockOffset` is checked on every Interest rather than only the "initial" Interest.
     * It is the same behavior as ndn-cxx v0.7.1 implementation.
     * This logic offers better consistency as it has less dependency on internal state of the
     * SignedInterestPolicy. However, persistently sending more than 1000 signed Interests per second
     * would eventually push SigTime out of `maxClockOffset` range and cause rejections.
     */
    function Time(opts?: TimeOptions): Rule;
    interface SeqNumOptions {
        /**
         * Initial sequence number.
         * @default 0
         */
        initialSeqNum?: number;
    }
    /**
     * Create a rule to assign or check SigSeqNum.
     *
     * This rule assigns SigSeqNum to `initialSegNum`, or increments from previous value.
     *
     * This rule rejects an Interest on any of these conditions:
     * (1) SigSeqNum is absent.
     * (2) SigSeqNum value is less than or equal to a previous value.
     */
    function SeqNum(opts?: SeqNumOptions): Rule;
}

export const TT: {
    Name: number;
    GenericNameComponent: number;
    ImplicitSha256DigestComponent: number;
    ParametersSha256DigestComponent: number;
    Interest: number;
    CanBePrefix: number;
    MustBeFresh: number;
    ForwardingHint: number;
    Delegation: number;
    Preference: number;
    Nonce: number;
    InterestLifetime: number;
    HopLimit: number;
    AppParameters: number;
    ISigInfo: number;
    ISigValue: number;
    Data: number;
    MetaInfo: number;
    ContentType: number;
    FreshnessPeriod: number;
    FinalBlock: number;
    Content: number;
    DSigInfo: number;
    DSigValue: number;
    SigType: number;
    KeyLocator: number;
    KeyDigest: number;
    SigNonce: number;
    SigTime: number;
    SigSeqNum: number;
    Nack: number;
    NackReason: number;
};
export const SigType: {
    Sha256: number;
    Sha256WithRsa: number;
    Sha256WithEcdsa: number;
    HmacWithSha256: number;
    Null: number;
};
export const NackReason: {
    Congestion: number;
    Duplicate: number;
    NoRoute: number;
};

/** Nack header. */
export class NackHeader {
    get reason(): number;
    set reason(v: number);
    private reason_;
    static decodeFrom(decoder: Decoder): NackHeader;
    constructor(reason?: number);
    encodeTo(encoder: Encoder): void;
}
/** Nack packet. */
export class Nack {
    get reason(): number;
    set reason(v: number);
    header: NackHeader;
    interest: Interest;
    constructor(interest: Interest, header?: NackHeader | number);
}

export const packet_lpm: typeof lpm;
type packet_AltUriConverter = AltUriConverter;
export const packet_AltUriConverter: typeof AltUriConverter;
export const packet_AltUri: typeof AltUri;
type packet_ComponentLike = ComponentLike;
export const packet_Component: typeof Component;
export const packet_NamingConvention: typeof NamingConvention;
export const packet_ImplicitDigest: typeof ImplicitDigest;
export const packet_ParamsDigest: typeof ParamsDigest;
type packet_NameLike = NameLike;
export const packet_Name: typeof Name;
export const packet_LLEncrypt: typeof LLEncrypt;
export const packet_LLDecrypt: typeof LLDecrypt;
type packet_Encrypter<_0> = Encrypter<_0>;
type packet_Decrypter<_0> = Decrypter<_0>;
export const packet_noopEncryption: typeof noopEncryption;
export const packet_SignedInterestPolicy: typeof SignedInterestPolicy;
export const packet_LLSign: typeof LLSign;
export const packet_LLVerify: typeof LLVerify;
export const packet_Signer: typeof Signer;
export const packet_Verifier: typeof Verifier;
export const packet_noopSigning: typeof noopSigning;
export const packet_digestSigning: typeof digestSigning;
export const packet_nullSigner: typeof nullSigner;
export const packet_TT: typeof TT;
export const packet_SigType: typeof SigType;
export const packet_NackReason: typeof NackReason;
export const packet_Data: typeof Data;
export const packet_FwHint: typeof FwHint;
export const packet_Interest: typeof Interest;
export const packet_KeyLocator: typeof KeyLocator;
type packet_NackHeader = NackHeader;
export const packet_NackHeader: typeof NackHeader;
type packet_Nack = Nack;
export const packet_Nack: typeof Nack;
export const packet_SigInfo: typeof SigInfo;
export namespace packet {
  export {
    packet_lpm as lpm,
    packet_AltUriConverter as AltUriConverter,
    packet_AltUri as AltUri,
    packet_ComponentLike as ComponentLike,
    packet_Component as Component,
    packet_NamingConvention as NamingConvention,
    packet_ImplicitDigest as ImplicitDigest,
    packet_ParamsDigest as ParamsDigest,
    packet_NameLike as NameLike,
    packet_Name as Name,
    packet_LLEncrypt as LLEncrypt,
    packet_LLDecrypt as LLDecrypt,
    packet_Encrypter as Encrypter,
    packet_Decrypter as Decrypter,
    packet_noopEncryption as noopEncryption,
    packet_SignedInterestPolicy as SignedInterestPolicy,
    packet_LLSign as LLSign,
    packet_LLVerify as LLVerify,
    packet_Signer as Signer,
    packet_Verifier as Verifier,
    packet_noopSigning as noopSigning,
    packet_digestSigning as digestSigning,
    packet_nullSigner as nullSigner,
    packet_TT as TT,
    packet_SigType as SigType,
    packet_NackReason as NackReason,
    packet_Data as Data,
    packet_FwHint as FwHint,
    packet_Interest as Interest,
    packet_KeyLocator as KeyLocator,
    packet_NackHeader as NackHeader,
    packet_Nack as Nack,
    packet_SigInfo as SigInfo,
  };
}

export type L3Pkt = Interest | Data | Nack;
/** A logical packet in the forwarder. */
interface FwPacket<T extends L3Pkt = L3Pkt> {
    l3: T;
    token?: unknown;
    reject?: RejectInterest.Reason;
    cancel?: boolean;
}
export namespace FwPacket {
    function create<T extends L3Pkt>(l3: T, token?: unknown): FwPacket<T>;
    /** Whether this is a plain packet that can be sent on the wire. */
    function isEncodable({ reject, cancel }: FwPacket): boolean;
}
/** Indicate an Interest has been rejected. */
export class RejectInterest implements FwPacket<Interest> {
    reject: RejectInterest.Reason;
    l3: Interest;
    token?: unknown;
    constructor(reject: RejectInterest.Reason, l3: Interest, token?: unknown);
}
export namespace RejectInterest {
    type Reason = "cancel" | "expire";
}

type Arguments<T> = [T] extends [(...args: infer U) => any]
  ? U
  : [T] extends [void] ? [] : [T]

/**
 * Type-safe event emitter.
 *
 * Use it like this:
 *
 * interface MyEvents {
 *   error: (error: Error) => void
 *   message: (from: string, content: string) => void
 * }
 *
 * const myEmitter = new EventEmitter() as TypedEmitter<MyEvents>
 *
 * myEmitter.on("message", (from, content) => {
 *   // ...
 * })
 *
 * myEmitter.emit("error", "x")  // <- Will catch this type error
 */
interface TypedEventEmitter<Events> {
  addListener<E extends keyof Events> (event: E, listener: Events[E]): this
  on<E extends keyof Events> (event: E, listener: Events[E]): this
  once<E extends keyof Events> (event: E, listener: Events[E]): this
  prependListener<E extends keyof Events> (event: E, listener: Events[E]): this
  prependOnceListener<E extends keyof Events> (event: E, listener: Events[E]): this

  off<E extends keyof Events>(event: E, listener: Events[E]): this
  removeAllListeners<E extends keyof Events> (event?: E): this
  removeListener<E extends keyof Events> (event: E, listener: Events[E]): this

  emit<E extends keyof Events> (event: E, ...args: Arguments<Events[E]>): boolean
  eventNames (): (keyof Events | string | symbol)[]
  rawListeners<E extends keyof Events> (event: E): Function[]
  listeners<E extends keyof Events> (event: E): Function[]
  listenerCount<E extends keyof Events> (event: E): number

  getMaxListeners (): number
  setMaxListeners (maxListeners: number): this
}

/**
 * Mnemonist DefaultMap Typings
 * =============================
 */
export class DefaultMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;

  // Constructor
  constructor(factory: (key: K, index: number) => V);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  peek(key: K): V | undefined;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static autoIncrement(): number;
}

export class FibEntry {
    readonly nexthops: Set<FaceImpl>;
}
export class Fib {
    readonly table: DefaultMap<string, FibEntry>;
    insert(face: FaceImpl, nameHex: string): void;
    delete(face: FaceImpl, nameHex: string): void;
    lpm(name: Name): FibEntry | undefined;
}

/** Downstream of pending Interest. */
interface PitDn {
    /** How many times this downstream has (re)transmitted the Interest. */
    nRx: number;
    /** Expiration time of this pending Interest at downstream. */
    expire: number;
    /** Last nonce from this downstream. */
    nonce: number;
    /** Last InterestToken from this downstream. */
    token: unknown;
}
/** Aggregated pending Interests from one or more downstream faces. */
export class PitEntry {
    private readonly pit;
    readonly key: string;
    /** Representative Interest. */
    readonly interest: Interest;
    /** Outgoing numeric PIT token. */
    token?: number;
    /** Downstream records. */
    dnRecords: DefaultMap<FaceImpl, PitDn>;
    /** Last expiration time among downstream. */
    lastExpire: number;
    /** Entry expiration timer; should match this.lastExpire. */
    expireTimer?: NodeJS.Timer | number;
    constructor(pit: Pit, key: string, interest: Interest);
    /** Record Interest from downstream. */
    receiveInterest(face: FaceImpl, { l3: interest, token }: FwPacket<Interest>): void;
    /** Record Interest cancellation from downstream. */
    cancelInterest(face: FaceImpl): void;
    /** Forward Interest to upstream. */
    forwardInterest(face: FaceImpl): void;
    /** Determine which downstream faces should receive Data from upstream. */
    returnData(up: FaceImpl): Iterable<{
        dn: FaceImpl;
        token: unknown;
    }>;
    private updateExpire;
    private expire;
}
/** Pending Interest table. */
export class Pit {
    readonly byName: Map<string, PitEntry>;
    readonly byToken: Map<number, PitEntry>;
    private lastToken;
    /**
     * true: try to match Data without token.
     * false: Data without token.
     * callback function: invoked when Data without token matches PIT entry.
     *   return true: deliver matched PIT entry.
     *   return false: drop Data.
     */
    dataNoTokenMatch: boolean | ((data: Data, key: string) => boolean);
    private generateToken;
    insertEntry(entry: PitEntry): void;
    eraseEntry(entry: PitEntry): void;
    /** Find or insert entry. */
    lookup(interest: FwPacket<Interest>): PitEntry;
    /** Find entry, disallow insertion. */
    lookup(interest: FwPacket<Interest>, canInsert: false): PitEntry | undefined;
    /**
     * Satisfy pending Interests with incoming Data.
     * @returns true if Data satisfies any pending Interest, or false if Data is unsolicited.
     */
    satisfy(face: FaceImpl, { l3: data, token }: FwPacket<Data>): Promise<boolean>;
    private findPotentialMatches;
}

export namespace pushable {
  export interface Pushable<T> extends AsyncIterable<T> {
    push: (value: T) => this,
    end: (err?: Error) => this
  }

  export interface PushableV<T> extends AsyncIterable<T[]> {
    push: (value: T) => this,
    end: (err?: Error) => this
  }

  type Options = {
    onEnd?: (err?: Error) => void,
    writev?: false
  }

  type OptionsV = {
    onEnd?: (err?: Error) => void,
    writev: true
  }
}

export function pushable<T> (options?: pushable.Options): pushable.Pushable<T>
export function pushable<T> (options: pushable.OptionsV): pushable.PushableV<T>

interface MultiMapConstructor {
  new <K, V>(container: SetConstructor): MultiMap<K, V, Set<V>>;
  new <K, V>(container?: ArrayConstructor): MultiMap<K, V, V[]>;

  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container: SetConstructor
  ): MultiMap<K, V, Set<V>>;
  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container?: ArrayConstructor
  ): MultiMap<K, V, V[]>;
}
/**
 * Mnemonist MultiMap Typings
 * ===========================
 */

interface MultiMap<K, V, C extends V[] | Set<V> = V[]> extends Iterable<[K, V]> {

  // Members
  dimension: number;
  size: number;

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  remove(key: K, value: V): boolean;
  has(key: K): boolean;
  get(key: K): C | undefined;
  multiplicity(key: K): number;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  forEachAssociation(callback: (value: C, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  containers(): IterableIterator<C>;
  associations(): IterableIterator<[K, C]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;
  toJSON(): any;
}

export const MultiMap: MultiMapConstructor;

// Type definitions for retry 0.12
// Project: https://github.com/tim-kos/node-retry
// Definitions by: Stan Goldmann <https://github.com/krenor>
//                 BendingBender <https://github.com/BendingBender>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.3

interface RetryOperation {
    /**
     * Returns an array of all errors that have been passed to `retryOperation.retry()` so far.
     * The returning array has the errors ordered chronologically based on when they were passed to
     * `retryOperation.retry()`, which means the first passed error is at index zero and the last is at the last index.
     */
    errors(): Error[];

    /**
     * A reference to the error object that occured most frequently.
     * Errors are compared using the `error.message` property.
     * If multiple error messages occured the same amount of time, the last error object with that message is returned.
     *
     * @return If no errors occured so far the value will be `null`.
     */
    mainError(): Error | null;

    /**
     * Defines the function that is to be retried and executes it for the first time right away.
     *
     * @param fn The function that is to be retried. `currentAttempt` represents the number of attempts
     * callback has been executed so far.
     * @param [timeoutOps.timeout] A timeout in milliseconds.
     * @param [timeoutOps.callback] Callback to execute when the operation takes longer than the timeout.
     */
    attempt(fn: (currentAttempt: number) => void, timeoutOps?: AttemptTimeoutOptions): void;

    /**
     * Returns `false` when no `error` value is given, or the maximum amount of retries has been reached.
     * Otherwise it returns `true`, and retries the operation after the timeout for the current attempt number.
     */
    retry(err?: Error): boolean;

    /**
     * Stops the operation being retried. Useful for aborting the operation on a fatal error etc.
     */
    stop(): void;

    /**
     * Resets the internal state of the operation object, so that you can call `attempt()` again as if
     * this was a new operation object.
     */
    reset(): void;

    /**
     * Returns an int representing the number of attempts it took to call `fn` before it was successful.
     */
    attempts(): number;
}

interface AttemptTimeoutOptions {
    /**
     * A timeout in milliseconds.
     */
    timeout?: number;
    /**
     * Callback to execute when the operation takes longer than the timeout.
     */
    callback?(): void;
}

interface OperationOptions extends TimeoutsOptions {
    /**
     * Whether to retry forever.
     * @default false
     */
    forever?: boolean;
    /**
     * Whether to [unref](https://nodejs.org/api/timers.html#timers_unref) the setTimeout's.
     * @default false
     */
    unref?: boolean;
    /**
     * The maximum time (in milliseconds) that the retried operation is allowed to run.
     * @default Infinity
     */
    maxRetryTime?: number;
}

interface TimeoutsOptions extends CreateTimeoutOptions {
    /**
     * The maximum amount of times to retry the operation.
     * @default 10
     */
    retries?: number;
}

interface CreateTimeoutOptions {
    /**
     * The exponential factor to use.
     * @default 2
     */
    factor?: number;
    /**
     * The number of milliseconds before starting the first retry.
     * @default 1000
     */
    minTimeout?: number;
    /**
     * The maximum number of milliseconds between two retries.
     * @default Infinity
     */
    maxTimeout?: number;
    /**
     * Randomizes the timeouts by multiplying a factor between 1-2.
     * @default false
     */
    randomize?: boolean;
}

/**
 * Manage advertised prefix of the forwarder.
 *
 * This class keeps track of what prefixes are announced by the owning forwarder.
 * It accepts announcements from faces attached to the forwarder, and then informs
 * each destination on what prefixes should be advertised.
 */
export class Readvertise {
    readonly fw: ForwarderImpl;
    constructor(fw: ForwarderImpl);
    readonly announcements: MultiMap<string, FaceImpl, Set<FaceImpl>>;
    readonly destinations: Set<ReadvertiseDestination<{}>>;
    addAnnouncement(face: FaceImpl, name: Name, nameHex: string): void;
    removeAnnouncement(face: FaceImpl, name: Name | undefined, nameHex: string): void;
}
/**
 * A destination of prefix advertisement.
 *
 * Generally, a prefix advertised to a destination would cause Interests matching the prefix
 * to come to the forwarder. aka prefix registration.
 */
export abstract class ReadvertiseDestination<State extends {} = {}> {
    private readonly retryOptions;
    private readvertise?;
    protected readonly table: Map<string, ReadvertiseDestination.Record<State>>;
    protected readonly queue: pushable.Pushable<string>;
    protected closed: boolean;
    constructor(retryOptions?: ReadvertiseDestination.RetryOptions);
    /** Enable and attach to a forwarder. */
    enable(fw: Forwarder): void;
    /**
     * Disable and detach from forwarder.
     *
     * Once detached, this instance is no longer usable.
     */
    disable(): void;
    /** Set a prefix to be advertised. */
    advertise(name: Name, nameHex: string): void;
    /** Set a prefix to be withdrawn. */
    withdraw(name: Name, nameHex: string): void;
    private restart;
    private process;
    /** Create per-prefix state. */
    protected makeState(name: Name, nameHex: string): State;
    /** Advertise a prefix once. */
    protected abstract doAdvertise(name: Name, state: State, nameHex: string): Promise<void>;
    /** Withdraw a prefix once. */
    protected abstract doWithdraw(name: Name, state: State, nameHex: string): Promise<void>;
}
export namespace ReadvertiseDestination {
    type RetryOptions = OperationOptions;
    enum Status {
        ADVERTISING = 0,
        ADVERTISED = 1,
        WITHDRAWING = 2,
        WITHDRAWN = 3
    }
    interface Record<State> {
        name: Name;
        status: Status;
        retry?: RetryOperation;
        state: State;
    }
}

interface Events$6 {
    /** Emitted before adding face. */
    faceadd: (face: FwFace) => void;
    /** Emitted after removing face. */
    facerm: (face: FwFace) => void;
    /** Emitted before adding prefix to face. */
    prefixadd: (face: FwFace, prefix: Name) => void;
    /** Emitted after removing prefix from face. */
    prefixrm: (face: FwFace, prefix: Name) => void;
    /** Emitted before advertising prefix. */
    annadd: (announcement: Name) => void;
    /** Emitted before withdrawing prefix. */
    annrm: (announcement: Name) => void;
    /** Emitted after packet arrival. */
    pktrx: (face: FwFace, pkt: FwPacket) => void;
    /** Emitted before packet transmission. */
    pkttx: (face: FwFace, pkt: FwPacket) => void;
}
export const ForwarderImpl_base: new () => TypedEventEmitter<Events$6>;
export class ForwarderImpl extends ForwarderImpl_base implements Forwarder {
    readonly options: Forwarder.Options;
    /** Node names, used in forwarding hint processing. */
    readonly nodeNames: Name[];
    readonly faces: Set<FaceImpl>;
    readonly fib: Fib;
    readonly pit: Pit;
    readonly readvertise: Readvertise;
    constructor(options: Forwarder.Options);
    /** Add a face to the forwarding plane. */
    addFace(face: FwFace.RxTx | FwFace.RxTxTransform, attributes?: FwFace.Attributes): FwFace;
    private pickInterestForwardingName;
    /** Process incoming Interest. */
    processInterest(face: FaceImpl, pkt: FwPacket<Interest>): void;
    /** Process incoming cancel Interest request. */
    cancelInterest(face: FaceImpl, pkt: FwPacket<Interest>): void;
    /** Process incoming Data. */
    processData(face: FaceImpl, pkt: FwPacket<Data>): void;
    /** Process incoming Nack. */
    processNack(face: FaceImpl, nack: FwPacket<Nack>): void;
}
/** Forwarding plane. */
interface Forwarder extends Pick<ForwarderImpl, "nodeNames" | "addFace" | Exclude<keyof TypedEventEmitter<Events$6>, "emit">> {
    readonly faces: Set<FwFace>;
    readonly pit: Pick<Pit, "dataNoTokenMatch">;
}
export namespace Forwarder {
    type Options = FaceImpl.Options;
    /** Create a new forwarding plane. */
    function create(options?: Options): Forwarder;
    /** Access the default forwarding plane instance. */
    function getDefault(): Forwarder;
    /** Delete default instance (mainly for unit testing). */
    function deleteDefault(): void;
}

interface Events$5 {
    /** Emitted upon face closing. */
    close: () => void;
}
export const FaceImpl_base: new () => TypedEventEmitter<Events$5>;
export class FaceImpl extends FaceImpl_base {
    readonly fw: ForwarderImpl;
    readonly attributes: FwFace.Attributes;
    private readonly routes;
    private readonly announcements;
    private readonly stopping;
    running: boolean;
    private readonly txQueue;
    txQueueLength: number;
    constructor(fw: ForwarderImpl, rxtx: FwFace.RxTx | FwFace.RxTxTransform, attributes: FwFace.Attributes);
    /** Shutdown the face. */
    close(): void;
    toString(): string;
    /** Determine if a route is present on the face. */
    hasRoute(name: Name): boolean;
    /** Add a route toward the face. */
    addRoute(name: Name, announcement?: FwFace.RouteAnnouncement): void;
    /** Remove a route toward the face. */
    removeRoute(name: Name, announcement?: FwFace.RouteAnnouncement): void;
    /** Add a prefix announcement associated with the face. */
    addAnnouncement(name: Name): void;
    /** Remove a prefix announcement associated with the face. */
    removeAnnouncement(name: Name): void;
    /** Transmit a packet on the face. */
    send(pkt: FwPacket): void;
    private rxLoop;
    private txLoop;
}
export namespace FaceImpl {
    interface Options {
        faceRxBuffer: number;
        faceTxBuffer: number;
    }
    const DefaultOptions: Options;
}
/** A socket or network interface associated with forwarding plane. */
interface FwFace extends Pick<FaceImpl, "attributes" | "close" | "toString" | "hasRoute" | "addRoute" | "removeRoute" | "addAnnouncement" | "removeAnnouncement" | Exclude<keyof TypedEventEmitter<Events$5>, "emit">> {
    readonly fw: Forwarder;
    readonly running: boolean;
    readonly txQueueLength: number;
}
export namespace FwFace {
    export interface Attributes extends Record<string, any> {
        /** Short string to identify the face. */
        describe?: string;
        /** Whether face is local. Default is false. */
        local?: boolean;
        /** Whether to readvertise registered routes. Default is true. */
        advertiseFrom?: boolean;
    }
    export type RouteAnnouncement = boolean | number | Name;
    interface RxTxBase {
        readonly attributes?: Attributes;
    }
    export interface RxTx extends RxTxBase {
        rx: AsyncIterable<FwPacket>;
        tx: (iterable: AsyncIterable<FwPacket>) => void;
    }
    export interface RxTxTransform extends RxTxBase {
        /**
         * The transform function takes an iterable of packets sent by the forwarder,
         * and returns an iterable of packets received by the forwarder.
         */
        transform: (iterable: AsyncIterable<FwPacket>) => AsyncIterable<FwPacket>;
    }
    export {};
}

/**
 * `Event` interface.
 * @see https://dom.spec.whatwg.org/#event
 */
interface Event {
    /**
     * The type of this event.
     */
    readonly type: string

    /**
     * The target of this event.
     */
    readonly target: EventTarget<{}, {}, "standard"> | null

    /**
     * The current target of this event.
     */
    readonly currentTarget: EventTarget<{}, {}, "standard"> | null

    /**
     * The target of this event.
     * @deprecated
     */
    readonly srcElement: any | null

    /**
     * The composed path of this event.
     */
    composedPath(): EventTarget<{}, {}, "standard">[]

    /**
     * Constant of NONE.
     */
    readonly NONE: number

    /**
     * Constant of CAPTURING_PHASE.
     */
    readonly CAPTURING_PHASE: number

    /**
     * Constant of BUBBLING_PHASE.
     */
    readonly BUBBLING_PHASE: number

    /**
     * Constant of AT_TARGET.
     */
    readonly AT_TARGET: number

    /**
     * Indicates which phase of the event flow is currently being evaluated.
     */
    readonly eventPhase: number

    /**
     * Stop event bubbling.
     */
    stopPropagation(): void

    /**
     * Stop event bubbling.
     */
    stopImmediatePropagation(): void

    /**
     * Initialize event.
     * @deprecated
     */
    initEvent(type: string, bubbles?: boolean, cancelable?: boolean): void

    /**
     * The flag indicating bubbling.
     */
    readonly bubbles: boolean

    /**
     * Stop event bubbling.
     * @deprecated
     */
    cancelBubble: boolean

    /**
     * Set or get cancellation flag.
     * @deprecated
     */
    returnValue: boolean

    /**
     * The flag indicating whether the event can be canceled.
     */
    readonly cancelable: boolean

    /**
     * Cancel this event.
     */
    preventDefault(): void

    /**
     * The flag to indicating whether the event was canceled.
     */
    readonly defaultPrevented: boolean

    /**
     * The flag to indicating if event is composed.
     */
    readonly composed: boolean

    /**
     * Indicates whether the event was dispatched by the user agent.
     */
    readonly isTrusted: boolean

    /**
     * The unix time of this event.
     */
    readonly timeStamp: number
}

/**
 * The constructor of `EventTarget` interface.
 */
type EventTargetConstructor<
    TEvents extends EventTarget.EventDefinition = {},
    TEventAttributes extends EventTarget.EventDefinition = {},
    TMode extends EventTarget.Mode = "loose"
> = {
    prototype: EventTarget<TEvents, TEventAttributes, TMode>
    new(): EventTarget<TEvents, TEventAttributes, TMode>
}

/**
 * `EventTarget` interface.
 * @see https://dom.spec.whatwg.org/#interface-eventtarget
 */
type EventTarget<
    TEvents extends EventTarget.EventDefinition = {},
    TEventAttributes extends EventTarget.EventDefinition = {},
    TMode extends EventTarget.Mode = "loose"
> = EventTarget.EventAttributes<TEventAttributes> & {
    /**
     * Add a given listener to this event target.
     * @param eventName The event name to add.
     * @param listener The listener to add.
     * @param options The options for this listener.
     */
    addEventListener<TEventType extends EventTarget.EventType<TEvents, TMode>>(
        type: TEventType,
        listener:
            | EventTarget.Listener<EventTarget.PickEvent<TEvents, TEventType>>
            | null,
        options?: boolean | EventTarget.AddOptions
    ): void

    /**
     * Remove a given listener from this event target.
     * @param eventName The event name to remove.
     * @param listener The listener to remove.
     * @param options The options for this listener.
     */
    removeEventListener<TEventType extends EventTarget.EventType<TEvents, TMode>>(
        type: TEventType,
        listener:
            | EventTarget.Listener<EventTarget.PickEvent<TEvents, TEventType>>
            | null,
        options?: boolean | EventTarget.RemoveOptions
    ): void

    /**
     * Dispatch a given event.
     * @param event The event to dispatch.
     * @returns `false` if canceled.
     */
    dispatchEvent<TEventType extends EventTarget.EventType<TEvents, TMode>>(
        event: EventTarget.EventData<TEvents, TEventType, TMode>
    ): boolean
}

export const EventTarget: EventTargetConstructor & {
    /**
     * Create an `EventTarget` instance with detailed event definition.
     *
     * The detailed event definition requires to use `defineEventAttribute()`
     * function later.
     *
     * Unfortunately, the second type parameter `TEventAttributes` was needed
     * because we cannot compute string literal types.
     *
     * @example
     * const signal = new EventTarget<{ abort: Event }, { onabort: Event }>()
     * defineEventAttribute(signal, "abort")
     */
    new <
        TEvents extends EventTarget.EventDefinition,
        TEventAttributes extends EventTarget.EventDefinition,
        TMode extends EventTarget.Mode = "loose"
    >(): EventTarget<TEvents, TEventAttributes, TMode>

    /**
     * Define an `EventTarget` constructor with attribute events and detailed event definition.
     *
     * Unfortunately, the second type parameter `TEventAttributes` was needed
     * because we cannot compute string literal types.
     *
     * @example
     * class AbortSignal extends EventTarget<{ abort: Event }, { onabort: Event }>("abort") {
     *      abort(): void {}
     * }
     *
     * @param events Optional event attributes (e.g. passing in `"click"` adds `onclick` to prototype).
     */
    <
        TEvents extends EventTarget.EventDefinition = {},
        TEventAttributes extends EventTarget.EventDefinition = {},
        TMode extends EventTarget.Mode = "loose"
    >(events: string[]): EventTargetConstructor<
        TEvents,
        TEventAttributes,
        TMode
    >

    /**
     * Define an `EventTarget` constructor with attribute events and detailed event definition.
     *
     * Unfortunately, the second type parameter `TEventAttributes` was needed
     * because we cannot compute string literal types.
     *
     * @example
     * class AbortSignal extends EventTarget<{ abort: Event }, { onabort: Event }>("abort") {
     *      abort(): void {}
     * }
     *
     * @param events Optional event attributes (e.g. passing in `"click"` adds `onclick` to prototype).
     */
    <
        TEvents extends EventTarget.EventDefinition = {},
        TEventAttributes extends EventTarget.EventDefinition = {},
        TMode extends EventTarget.Mode = "loose"
    >(event0: string, ...events: string[]): EventTargetConstructor<
        TEvents,
        TEventAttributes,
        TMode
    >
}

export namespace EventTarget {
    /**
     * Options of `removeEventListener()` method.
     */
    export interface RemoveOptions {
        /**
         * The flag to indicate that the listener is for the capturing phase.
         */
        capture?: boolean
    }

    /**
     * Options of `addEventListener()` method.
     */
    export interface AddOptions extends RemoveOptions {
        /**
         * The flag to indicate that the listener doesn't support
         * `event.preventDefault()` operation.
         */
        passive?: boolean
        /**
         * The flag to indicate that the listener will be removed on the first
         * event.
         */
        once?: boolean
    }

    /**
     * The type of regular listeners.
     */
    export interface FunctionListener<TEvent> {
        (event: TEvent): void
    }

    /**
     * The type of object listeners.
     */
    export interface ObjectListener<TEvent> {
        handleEvent(event: TEvent): void
    }

    /**
     * The type of listeners.
     */
    export type Listener<TEvent> =
        | FunctionListener<TEvent>
        | ObjectListener<TEvent>

    /**
     * Event definition.
     */
    export type EventDefinition = {
        readonly [key: string]: Event
    }

    /**
     * Mapped type for event attributes.
     */
    export type EventAttributes<TEventAttributes extends EventDefinition> = {
        [P in keyof TEventAttributes]:
            | FunctionListener<TEventAttributes[P]>
            | null
    }

    /**
     * The type of event data for `dispatchEvent()` method.
     */
    export type EventData<
        TEvents extends EventDefinition,
        TEventType extends keyof TEvents | string,
        TMode extends Mode
    > =
        TEventType extends keyof TEvents
            ? (
                // Require properties which are not generated automatically.
                & Pick<
                    TEvents[TEventType],
                    Exclude<keyof TEvents[TEventType], OmittableEventKeys>
                >
                // Properties which are generated automatically are optional.
                & Partial<Pick<Event, OmittableEventKeys>>
            )
            : (
                TMode extends "standard"
                    ? Event
                    : Event | NonStandardEvent
            )

    /**
     * The string literal types of the properties which are generated
     * automatically in `dispatchEvent()` method.
     */
    export type OmittableEventKeys = Exclude<keyof Event, "type">

    /**
     * The type of event data.
     */
    export type NonStandardEvent = {
        [key: string]: any
        type: string
    }

    /**
     * The type of listeners.
     */
    export type PickEvent<
        TEvents extends EventDefinition,
        TEventType extends keyof TEvents | string,
    > =
        TEventType extends keyof TEvents
            ? TEvents[TEventType]
            : Event

    /**
     * Event type candidates.
     */
    export type EventType<
        TEvents extends EventDefinition,
        TMode extends Mode
    > =
        TMode extends "strict"
            ? keyof TEvents
            : keyof TEvents | string

    /**
     * - `"strict"` ..... Methods don't accept unknown events.
     *                    `dispatchEvent()` accepts partial objects.
     * - `"loose"` ...... Methods accept unknown events.
     *                    `dispatchEvent()` accepts partial objects.
     * - `"standard"` ... Methods accept unknown events.
     *                    `dispatchEvent()` doesn't accept partial objects.
     */
    export type Mode = "strict" | "standard" | "loose"
}

type Events$4 = {
    abort: any
}
type EventAttributes = {
    onabort: any
}
/**
 * The signal class.
 * @see https://dom.spec.whatwg.org/#abortsignal
 */
export class AbortSignal extends EventTarget<Events$4, EventAttributes> {
    /**
     * AbortSignal cannot be constructed directly.
     */
    constructor()
    /**
     * Returns `true` if this `AbortSignal`"s `AbortController` has signaled to abort, and `false` otherwise.
     */
    readonly aborted: boolean
}

interface Options$2 {
    /** Description for debugging purpose. */
    describe?: string;
    /**
     * Modify Interest according to specified options.
     * Default is no modification.
     */
    modifyInterest?: Interest.Modify;
    /**
     * Retransmission policy.
     * Default is disabling retransmission.
     */
    retx?: RetxPolicy;
    /** AbortSignal that allows canceling the Interest via AbortController. */
    signal?: AbortSignal | globalThis.AbortSignal;
    /**
     * Data verifier.
     * Default is no verification.
     */
    verifier?: Verifier;
}
/**
 * Progress of Data retrieval.
 *
 * This is a Promise that resolves with the retrieved Data, and rejects upon timeout.
 * Calling .cancel() cancels Data retrieval and rejects the Promise.
 */
export type Context = Promise<Data> & {
    readonly interest: Interest;
    readonly nRetx: number;
};
/** Consumer functionality of Endpoint. */
export class EndpointConsumer {
    fw: Forwarder;
    opts: Options$2;
    /** Consume a single piece of Data. */
    consume(interestInput: Interest | NameLike, opts?: Options$2): Context;
}

/** Outgoing Data buffer for producer. */
interface DataBuffer {
    find: (interest: Interest) => Promise<Data | undefined>;
    insert: (...pkts: Data[]) => Promise<void>;
}

/**
 * Producer handler function.
 *
 * The handler can return a Data to respond to the Interest, or return `undefined` to cause a timeout.
 *
 * If Options.dataBuffer is provided, the handler can access the DataBuffer via producer.dataBuffer .
 * The handler can return a Data to respond to the Interest, which is also inserted to the DataBuffer
 * unless Options.autoBuffer is set to false. If the handler returns `undefined`, the Interest is used
 * to query the DataBuffer, and any matching Data may be sent.
 */
export type Handler = (interest: Interest, producer: Producer) => Promise<Data | undefined>;
interface Options$1 {
    /** Description for debugging purpose. */
    describe?: string;
    /**
     * What name to be readvertised.
     * Ignored if prefix is undefined.
     */
    announcement?: EndpointProducer.RouteAnnouncement;
    /**
     * How many Interests to process in parallel.
     * Default is 1.
     */
    concurrency?: number;
    /**
     * If specified, automatically sign Data packets unless already signed.
     * This does not apply to Data packets manually inserted to the dataBuffer.
     */
    dataSigner?: Signer;
    /** Outgoing Data buffer. */
    dataBuffer?: DataBuffer;
    /**
     * Whether to add handler return value to buffer.
     * Default is true.
     * Ignored when dataBuffer is not specified.
     */
    autoBuffer?: boolean;
}
/** A running producer. */
interface Producer {
    readonly prefix: Name | undefined;
    readonly face: FwFace;
    readonly dataBuffer?: DataBuffer;
    /**
     * Process an Interest received elsewhere.
     *
     * Use case of this function:
     * 1. Producer A dynamically creates producer B upon receiving an Interest.
     * 2. Producer A can invoke this function to let producer B generate a response.
     * 3. The response should be sent by producer A.
     */
    processInterest: (interest: Interest) => Promise<Data | undefined>;
    /** Close the producer. */
    close: () => void;
}
/** Producer functionality of Endpoint. */
export class EndpointProducer {
    fw: Forwarder;
    opts: Options$1;
    /**
     * Start a producer.
     * @param prefixInput prefix registration; if undefined, prefixes may be added later.
     * @param handler function to handle incoming Interest.
     */
    produce(prefixInput: NameLike | undefined, handler: Handler, opts?: Options$1): Producer;
}
export namespace EndpointProducer {
    type RouteAnnouncement = FwFace.RouteAnnouncement;
}

interface Options extends Options$2, Options$1 {
    fw?: Forwarder;
}
/**
 * Endpoint is the main entrypoint for an application to interact with the forwarding plane.
 * It provides basic consumer and producer functionality.
 */
export class Endpoint {
    readonly opts: Options;
    readonly fw: Forwarder;
    constructor(opts?: Options);
}
interface Endpoint extends EndpointConsumer, EndpointProducer {
}
export namespace Endpoint {
    /** Delete default Forwarder instance (mainly for unit testing). */
    const deleteDefaultForwarder: typeof Forwarder.deleteDefault;
    type RouteAnnouncement = EndpointProducer.RouteAnnouncement;
}

// Type definitions for @root/asn1 1.0


interface Element$1<V extends string|Uint8Array> {
    type: number;
    lengthSize: number;
    length: number;
    value?: V;
    children?: Array<Element$1<V>>;
}

type ElementBuffer = Element$1<Uint8Array>;

export type If<Cond, True, False, Unknown = True | False> = Cond extends true ? True : Cond extends false ? False : Unknown;
/** WebCrypto based algorithm implementation. */
interface CryptoAlgorithm<I = any, Asym extends boolean = any, G = any> {
    /**
     * Identifies an algorithm in storage.
     * This should be changed when the serialization format changes.
     */
    readonly uuid: string;
    readonly keyUsages: If<Asym, Record<"private" | "public", KeyUsage[]>, Record<"secret", KeyUsage[]>, {}>;
    /** Generate key pair or secret key. */
    cryptoGenerate: (params: G, extractable: boolean) => Promise<Asym extends true ? CryptoAlgorithm.GeneratedKeyPair<I> : Asym extends false ? CryptoAlgorithm.GeneratedSecretKey<I> : never>;
    /**
     * Import public key from SPKI.
     *
     * This should only appear on asymmetric algorithm.
     */
    importSpki?: (spki: Uint8Array, der: ElementBuffer) => Promise<CryptoAlgorithm.PublicKey<I>>;
}
export namespace CryptoAlgorithm {
    function isAsym<I, G>(algo: CryptoAlgorithm<I, any, G>): algo is CryptoAlgorithm<I, true, G>;
    function isSym<I, G>(algo: CryptoAlgorithm<I, any, G>): algo is CryptoAlgorithm<I, false, G>;
    function isSigning<I, Asym extends boolean = any, G = any>(algo: CryptoAlgorithm<I, Asym, G>): algo is SigningAlgorithm<I, Asym, G>;
    function isEncryption<I, Asym extends boolean = any, G = any>(algo: CryptoAlgorithm<I, Asym, G>): algo is EncryptionAlgorithm<I, Asym, G>;
    interface PrivateKey<I = any> {
        privateKey: CryptoKey;
        info: I;
    }
    interface PublicKey<I = any> {
        publicKey: CryptoKey;
        spki: Uint8Array;
        info: I;
    }
    interface SecretKey<I = any> {
        secretKey: CryptoKey;
        info: I;
    }
    type PrivateSecretKey<I = any, Asym extends boolean = any> = If<Asym, PrivateKey<I>, SecretKey<I>>;
    type PublicSecretKey<I = any, Asym extends boolean = any> = If<Asym, PublicKey<I>, SecretKey<I>>;
    interface GeneratedKeyPair<I = any> extends PrivateKey<I>, PublicKey<I> {
        jwkImportParams: AlgorithmIdentifier;
    }
    interface GeneratedSecretKey<I = any> extends SecretKey<I> {
        jwkImportParams: AlgorithmIdentifier;
    }
}
/** WebCrypto based signing algorithm implementation. */
interface SigningAlgorithm<I = any, Asym extends boolean = any, G = any> extends CryptoAlgorithm<I, Asym, G> {
    readonly sigType: number;
    makeLLSign: If<Asym, (key: CryptoAlgorithm.PrivateKey<I>) => LLSign, (key: CryptoAlgorithm.SecretKey<I>) => LLSign, unknown>;
    makeLLVerify: If<Asym, (key: CryptoAlgorithm.PublicKey<I>) => LLVerify, (key: CryptoAlgorithm.SecretKey<I>) => LLVerify, unknown>;
}
/** WebCrypto based encryption algorithm implementation. */
interface EncryptionAlgorithm<I = any, Asym extends boolean = any, G = any> extends CryptoAlgorithm<I, Asym, G> {
    makeLLEncrypt: If<Asym, (key: CryptoAlgorithm.PublicKey<I>) => LLEncrypt, (key: CryptoAlgorithm.SecretKey<I>) => LLEncrypt, unknown>;
    makeLLDecrypt: If<Asym, (key: CryptoAlgorithm.PrivateKey<I>) => LLDecrypt, (key: CryptoAlgorithm.SecretKey<I>) => LLDecrypt, unknown>;
}

export class NFW {
    private gs;
    /** ID of this node */
    private readonly nodeId;
    /** NDNts forwarder */
    fw: Forwarder;
    private face;
    private faceRx;
    /** Security options */
    security?: {
        /** Signer object */
        signer: Signer;
        /** Verifier object */
        verifier: Verifier;
        /** Private key */
        privKey: CryptoKey;
        /** Public key */
        pubKey: CryptoKey;
        /** Generated key pair */
        keyPair: CryptoAlgorithm.GeneratedKeyPair;
    };
    /** Forwarding table */
    fib: any[];
    /** Captured packets for this node */
    readonly capturedPackets: any[];
    /** Enable packet capture */
    capture: boolean;
    /** Content Store */
    private cs;
    /** Routing strategies */
    readonly strategies: {
        prefix: Name;
        strategy: string;
    }[];
    /** Packets pending to be forwarded */
    private pendingTraffic;
    /** Server for ping */
    private pingServer?;
    /** Connections to other NFWs */
    private connections;
    /** Aggregate of sent interests */
    private pit;
    constructor(gs: GlobalService, node: INode);
    node(): INode;
    nodeUpdated(): void;
    capturePacket(p: any): void;
    private setupPingServer;
    updateColors(): void;
    /** Add traffic to link */
    private addLinkTraffic;
    private checkPrefixRegistrationMatches;
    private longestMatch;
    private allMatches;
    private expressInterest;
    strsFIB(): string[];
    getEndpoint(): Endpoint;
}

interface INode extends Node$1 {
    init?: boolean;
    producedPrefixes: string[];
    nfw: NFW;
    extra: {
        codeEdit: string;
    };
}
interface IEdge extends Edge {
    init?: boolean;
    latency: number;
    loss: number;
    extra: {
        pendingTraffic: number;
    };
}

/** Invertible Bloom Lookup Table. */
export class IBLT {
    constructor(p: IBLT.Parameters | IBLT.PreparedParameters);
    private readonly p;
    private readonly ht;
    /** Insert a key. */
    insert(key: number): void;
    /** Erase a key. */
    erase(key: number): void;
    private checkHash;
    private keyToBuffer;
    private update;
    private update2;
    /** Compute the difference between this (first) and other (second) IBLT. */
    diff(...others: IBLT[]): IBLT.Diff;
    /**
     * Serialize the hashtable to a byte array.
     *
     * Each entry is serialized as 12 octets:
     * - count: int32
     * - keySum: uint32
     * - keyCheck: uint32
     * These numbers are big endian.
     *
     * Return value shares the underlying memory. It must be copied when not using compression.
     */
    serialize(): Uint8Array;
    /**
     * Deserialize from a byte array.
     * @throws input does not match parameters.
     */
    deserialize(v: Uint8Array): void;
    /**
     * Clone to another IBLT.
     */
    clone(): IBLT;
}
export namespace IBLT {
    type HashFunction = (seed: number, input: Uint8Array) => number;
    /** IBLT parameters. */
    interface Parameters {
        /** Whether to use little endian when converting uint32 key to Uint8Array. */
        keyToBufferLittleEndian: boolean;
        /** Whether to use little endian when serializing uint32 and int32 fields. */
        serializeLittleEndian: boolean;
        /** 32-bit hash function. */
        hash: HashFunction;
        /** Number of hash keys. */
        nHash: number;
        /**
         * Hash function seed for KeyCheck field.
         * This must be greater than nHash.
         */
        checkSeed: number;
        /**
         * Number of hashtable entries.
         * This must be divisible by `nHash`.
         */
        nEntries: number;
    }
    class PreparedParameters implements Readonly<Parameters> {
        static prepare(p: Parameters): PreparedParameters;
        private constructor();
        readonly nBuckets: number;
    }
    interface PreparedParameters extends Readonly<Parameters> {
    }
    /** Difference between two IBLTs. */
    interface Diff {
        /** Whether all keys have been extracted. */
        success: boolean;
        /** Keys present in the first IBLT but absent in the second IBLT. */
        positive: Set<number>;
        /** Keys absent in the first IBLT but present in the second IBLT. */
        negative: Set<number>;
        /** Total number of keys in positive and negative sets. */
        total: number;
    }
}

export type IntervalRange = [min: number, max: number];

/** A sync protocol participant. */
interface SyncProtocol<ID = any> extends TypedEventEmitter<SyncProtocol.Events<ID>> {
    /** Stop the protocol operation. */
    close(): void;
    /** Retrieve a node. */
    get(id: ID): SyncNode<ID> | undefined;
    /** Retrieve or create a node. */
    add(id: ID): SyncNode<ID>;
}
export namespace SyncProtocol {
    interface Events<ID> {
        /** Emitted when a node is updated, i.e. has new sequence numbers. */
        update: (update: SyncUpdate<ID>) => void;
    }
}
/**
 * A sync protocol node.
 *
 * Each sync protocol participant may have zero or more nodes.
 */
interface SyncNode<ID = any> {
    /**
     * Node identifier.
     * This is typically a number or a Name.
     */
    readonly id: ID;
    /**
     * Current sequence number.
     * It can be increased, but cannot be decreased.
     */
    seqNum: number;
    /**
     * Remove this node from participating in the sync protocol.
     * This may or may not have effect, depending on the sync protocol.
     */
    remove(): void;
}
/** A received update regarding a node. */
export class SyncUpdate<ID = any> {
    readonly node: SyncNode<ID>;
    readonly loSeqNum: number;
    readonly hiSeqNum: number;
    /**
     * Constructor.
     * @param node the node.
     * @param loSeqNum low sequence number, inclusive.
     * @param hiSeqNum high sequence number, inclusive.
     */
    constructor(node: SyncNode<ID>, loSeqNum: number, hiSeqNum: number);
    /** Node identifier. */
    get id(): ID;
    /** Number of new sequence numbers. */
    get count(): number;
    /** Iterate over new sequence numbers. */
    seqNums(): Iterable<number>;
}
interface Subscriber<Topic = Name, Update = any, SubscribeInfo = Topic> {
    subscribe: (topic: SubscribeInfo) => Subscription<Topic, Update>;
}
/**
 * A subscription on a topic.
 * Listen to the 'update' event to receive updates on incoming publications matching the topic.
 */
interface Subscription<Topic = Name, Update = SyncUpdate<Topic>> extends TypedEventEmitter<Subscription.Events<Update>> {
    /** The topic. */
    readonly topic: Topic;
    /** Unsubscribe. */
    remove(): void;
}
export namespace Subscription {
    interface Events<Update> {
        /** Emitted when a subscription update is received. */
        update: (update: Update) => void;
    }
}

/** 32-bit hash function. */
export type HashFunction = (seed: number, input: Uint8Array) => number;
/**
 * Bloom filter algorithm parameters.
 *
 * All participants must agree on the same parameters in order to communicate.
 */
interface Parameters {
    hash: HashFunction;
    projectedElementCount: number;
    falsePositiveProbability: number;
}
/** A Bloom filter. */
export class BloomFilter {
    private readonly m;
    /**
     * Construct a Bloom filter.
     * @param p algorithm parameter.
     * @param wire decode from serialized wire encoding.
     * @returns a Promise that resolves to BloomFilter instance.
     */
    static create(p: Parameters, wire?: Uint8Array): Promise<BloomFilter>;
    /** Dispose this instance to prevent memory leak. */
    dispose(): void;
    /** Clear the Bloom filter. */
    clear(): void;
    /** Insert a value to the Bloom filter. */
    insert(s: string | Uint8Array): void;
    /** Determine whether the Bloom filter probably contains a value. */
    contains(s: string | Uint8Array): boolean;
    /** Serialize the Bloom filter. */
    encode(): Uint8Array;
    private constructor();
    private readonly c;
    private disposed;
    private throwIfDisposed;
    private readonly hashFunction;
}
interface BloomFilter extends Readonly<Parameters> {
}

interface Compression {
    compress: (input: Uint8Array) => Uint8Array;
    decompress: (compressed: Uint8Array) => Uint8Array;
}
export class IbltCodec {
    readonly ibltCompression: Compression;
    protected readonly ibltParams: IBLT.PreparedParameters;
    iblt2comp(iblt: IBLT): Component;
    comp2iblt(comp: Component): IBLT;
}

export class PSyncCore {
    constructor(p: PSyncCore.Parameters);
    readonly ibltParams: IBLT.PreparedParameters;
    readonly threshold: number;
    readonly joinPrefixSeqNum: (ps: PSyncCore.PrefixSeqNum) => PSyncCore.PrefixSeqNumEncoded;
    readonly nodes: Map<string, PSyncNode>;
    readonly keys: Map<number, PSyncNode>;
    readonly iblt: IBLT;
    get(prefix: Name): PSyncNode | undefined;
    add(prefix: Name): PSyncNode;
    list(filter: (node: PSyncNode) => boolean): PSyncCore.State;
    onIncreaseSeqNum?: (node: PSyncNode, prevSeqNum: number, prevKey: number) => void;
}
export namespace PSyncCore {
    interface PrefixSeqNum {
        prefix: Name;
        seqNum: number;
    }
    type State = PrefixSeqNum[];
    interface PrefixSeqNumEncoded {
        readonly value: Uint8Array;
        readonly hash: number;
    }
    interface Parameters {
        iblt: IBLT.Parameters;
        /** If IBLT diff has at least this number of entries, respond with SyncData right away. */
        threshold: number;
        /** Encode prefix and sequence number to byte array. */
        joinPrefixSeqNum: (ps: PrefixSeqNum) => PrefixSeqNumEncoded;
    }
}
export class PSyncNode implements SyncNode<Name>, PSyncCore.PrefixSeqNum {
    private readonly c;
    readonly id: Name;
    private readonly prefixHex;
    constructor(c: PSyncCore, id: Name, prefixHex: string);
    get prefix(): Name;
    get key(): number;
    private seq;
    private k;
    get seqNum(): number;
    set seqNum(v: number);
    /**
     * Change sequence number, for internal use.
     * @param v new sequence number.
     * @param triggerEvent whether to trigger onIncreaseSeqNum callback.
     */
    setSeqNum(v: number, triggerEvent?: boolean): void;
    remove(): void;
    /** Recompute `this.k` after changing sequence number. */
    private updateKey;
    private detachKey;
}

export class PSyncCodec {
    protected readonly ibltParams: IBLT.PreparedParameters;
    constructor(p: PSyncCodec.Parameters, ibltParams: IBLT.PreparedParameters);
    readonly uselessCompsAfterIblt: Component[];
    state2buffer(state: PSyncCore.State): Uint8Array;
    buffer2state(buffer: Uint8Array): PSyncCore.State;
}
interface PSyncCodec extends Readonly<PSyncCodec.Parameters>, IbltCodec {
}
export namespace PSyncCodec {
    type Compression = Compression;
    interface Parameters {
        /** Version convention for SyncData. */
        versionConvention: NamingConvention<number, number>;
        /** Segment number convention for SyncData. */
        segmentNumConvention: NamingConvention<number, number>;
        /** Compression method for IBLT in name component. */
        ibltCompression: Compression;
        /**
         * Number of useless components between IBLT and Version.
         * @see https://github.com/named-data/PSync/blob/b60398c5fc216a1b577b9dbcf61d48a21cb409a4/PSync/full-producer.cpp#L239
         */
        nUselessCompsAfterIblt: number;
        /** Compression method for State in segmented object. */
        contentCompression: Compression;
        /** Encode State to buffer (without compression). */
        encodeState: (state: PSyncCore.State) => Uint8Array;
        /** Decode State from buffer (without decompression). */
        decodeState: (payload: Uint8Array) => PSyncCore.State;
        /** Convert a name prefix to a Bloom filter key. */
        toBloomKey: (prefix: Name) => string | Uint8Array;
        /** Number of name components in an encoded Bloom filter. */
        encodeBloomLength: number;
        /** Encode a Bloom filter. */
        encodeBloom: (bf: BloomFilter) => Component[];
        /** Decode a Bloom filter. */
        decodeBloom: (Bloom: typeof BloomFilter, comps: readonly Component[]) => Promise<BloomFilter>;
    }
}

interface DebugEntry$3 {
    action: string;
    ownIblt: IBLT;
    recvIblt?: IBLT;
    state?: PSyncCore.State;
}
interface Events$3 extends SyncProtocol.Events<Name> {
    debug: (entry: DebugEntry$3) => void;
}
export const PSyncFull_base: new () => TypedEventEmitter<Events$3>;
/** PSync - FullSync participant. */
export class PSyncFull extends PSyncFull_base implements SyncProtocol<Name> {
    constructor({ p, endpoint, describe, syncPrefix, addSyncPrefixOnUplinks, syncReplyFreshness, signer, producerBufferLimit, syncInterestLifetime, syncInterestInterval, verifier, }: PSyncFull.Options);
    private readonly endpoint;
    readonly describe: string;
    private readonly syncPrefix;
    private readonly c;
    private readonly codec;
    private readonly uplinkRouteMirror?;
    private closed;
    private readonly pFreshness;
    private readonly pBuffer;
    private readonly pProducer;
    private readonly pPendings;
    private readonly cFetcher;
    private readonly cInterval;
    private cTimer;
    private cAbort?;
    private cCurrentInterestName?;
    private debug;
    /** Stop the protocol operation. */
    close(): void;
    get(prefix: Name): SyncNode<Name> | undefined;
    add(prefix: Name): SyncNode<Name>;
    private handleSyncInterest;
    private handleIncreaseSeqNum;
    private sendSyncData;
    private scheduleSyncInterest;
    private sendSyncInterest;
}
export namespace PSyncFull {
    interface Parameters extends PSyncCore.Parameters, PSyncCodec.Parameters {
    }
    interface Options {
        /**
         * Algorithm parameters.
         * They must be the same on every peer.
         */
        p: Parameters;
        /** Endpoint for communication. */
        endpoint?: Endpoint;
        /** Description for debugging purpose. */
        describe?: string;
        /** Sync group prefix. */
        syncPrefix: Name;
        /**
         * Whether to automatically add sync group prefix as a route on uplinks.
         * @default true
         */
        addSyncPrefixOnUplinks?: boolean;
        /**
         * FreshnessPeriod of sync reply Data packet.
         * @default 1000
         */
        syncReplyFreshness?: number;
        /**
         * Signer of sync reply Data packets.
         * Default is digest signing.
         */
        signer?: Signer;
        /**
         * How many sync reply segmented objects to keep in buffer.
         * This must be positive.
         * @default 32
         */
        producerBufferLimit?: number;
        /**
         * Sync Interest lifetime in milliseconds.
         * @default 1000
         */
        syncInterestLifetime?: number;
        /**
         * Interval between sync Interests, randomized within the range, in milliseconds.
         * @default [syncInterestLifetime/2+100,syncInterestLifetime/2+500]
         */
        syncInterestInterval?: IntervalRange;
        /**
         * Verifier of sync reply Data packets.
         * Default is no verification.
         */
        verifier?: Verifier;
    }
}

interface DebugEntry$2 {
    action: string;
    interestName?: Name;
}
interface Events$2 extends SyncProtocol.Events<Name> {
    debug: (entry: DebugEntry$2) => void;
}
export const PSyncPartialPublisher_base: new () => TypedEventEmitter<Events$2>;
/** PSync - PartialSync publisher. */
export class PSyncPartialPublisher extends PSyncPartialPublisher_base implements SyncProtocol<Name> {
    constructor({ p, endpoint, describe, syncPrefix, helloReplyFreshness, syncReplyFreshness, signer, producerBufferLimit, }: PSyncPartialPublisher.Options);
    private readonly endpoint;
    readonly describe: string;
    private readonly syncPrefix;
    private readonly c;
    private readonly codec;
    private closed;
    private readonly pBuffer;
    private readonly hFreshness;
    private readonly hProducer;
    private readonly sFreshness;
    private readonly sProducer;
    private readonly sPendings;
    private debug;
    /** Stop the protocol operation. */
    close(): void;
    get(prefix: Name): SyncNode<Name> | undefined;
    add(prefix: Name): SyncNode<Name>;
    private handleHelloInterest;
    private handleSyncInterest;
    private handleIncreaseSeqNum;
    private sendStateData;
}
export namespace PSyncPartialPublisher {
    interface Parameters extends PSyncCore.Parameters, PSyncCodec.Parameters {
    }
    interface Options {
        /**
         * Algorithm parameters.
         * They must match the subscriber parameters.
         */
        p: Parameters;
        /** Endpoint for communication. */
        endpoint?: Endpoint;
        /** Description for debugging purpose. */
        describe?: string;
        /** Sync producer prefix. */
        syncPrefix: Name;
        /**
         * FreshnessPeriod of hello reply Data packet.
         * @default 1000
         */
        helloReplyFreshness?: number;
        /**
         * FreshnessPeriod of sync reply Data packet.
         * @default 1000
         */
        syncReplyFreshness?: number;
        /**
         * Signer of sync reply Data packets.
         * Default is digest signing.
         */
        signer?: Signer;
        /**
         * How many sync reply segmented objects to keep in buffer.
         * This must be positive.
         * @default 32
         */
        producerBufferLimit?: number;
    }
}

export type Sub = Subscription<Name, SyncUpdate<Name>>;
export type Update = SyncUpdate<Name>;
interface DebugEntry$1 {
    action: string;
}
interface Events$1 {
    debug: (entry: DebugEntry$1) => void;
    state: (topics: readonly PSyncPartialSubscriber.TopicInfo[]) => void;
}
export const PSyncPartialSubscriber_base: new () => TypedEventEmitter<Events$1>;
/** PSync - PartialSync subscriber. */
export class PSyncPartialSubscriber extends PSyncPartialSubscriber_base implements Subscriber<Name, Update, PSyncPartialSubscriber.TopicInfo> {
    constructor({ p, endpoint, describe, syncPrefix, syncInterestLifetime, syncInterestInterval, verifier, }: PSyncPartialSubscriber.Options);
    readonly describe: string;
    private readonly helloPrefix;
    private readonly syncPrefix;
    private readonly codec;
    private readonly encodeBloom;
    private closed;
    private readonly subs;
    private readonly prevSeqNums;
    private bloom;
    private ibltComp?;
    private readonly cFetcher;
    private readonly cInterval;
    private cTimer;
    private cAbort?;
    private debug;
    /** Stop the protocol operation. */
    close(): void;
    subscribe(topic: PSyncPartialSubscriber.TopicInfo): Sub;
    private handleAddTopic;
    private handleRemoveTopic;
    private scheduleInterest;
    private sendInterest;
    private sendHelloInterest;
    private sendSyncInterest;
    private handleState;
}
export namespace PSyncPartialSubscriber {
    interface Parameters extends PSyncCore.Parameters, PSyncCodec.Parameters {
        bloom: Parameters;
    }
    interface Options {
        /**
         * Algorithm parameters.
         * They must match the publisher parameters.
         */
        p: Parameters;
        /** Endpoint for communication. */
        endpoint?: Endpoint;
        /** Description for debugging purpose. */
        describe?: string;
        /** Sync producer prefix. */
        syncPrefix: Name;
        /**
         * Sync Interest lifetime in milliseconds.
         * @default 1000
         */
        syncInterestLifetime?: number;
        /**
         * Interval between sync Interests, randomized within the range, in milliseconds.
         * @default [syncInterestLifetime/2+100,syncInterestLifetime/2+500]
         */
        syncInterestInterval?: [min: number, max: number];
        /**
         * Verifier of sync reply Data packets.
         * Default is no verification.
         */
        verifier?: Verifier;
    }
    interface TopicInfo extends PSyncCore.PrefixSeqNum {
    }
}

/** Create algorithm parameters to be compatible with PSync C++ library. */
export function makePSyncCompatParam({ keyToBufferLittleEndian, expectedEntries, expectedSubscriptions, ibltCompression, contentCompression, }?: makePSyncCompatParam.Options): PSyncFull.Parameters & PSyncPartialPublisher.Parameters & PSyncPartialSubscriber.Parameters;
export namespace makePSyncCompatParam {
    interface Options {
        /**
         * Whether to use little endian when converting uint32 key to Uint8Array.
         * PSync C++ library behaves differently on big endian and little endian machines,
         * https://github.com/named-data/PSync/blob/b60398c5fc216a1b577b9dbcf61d48a21cb409a4/PSync/detail/util.cpp#L126
         * This must be set to match other peers.
         * @default true
         */
        keyToBufferLittleEndian?: boolean;
        /**
         * Expected number of IBLT entries, i.e. expected number of updates in a sync cycle.
         * This is irrelevant to PartialSync consumer.
         * @default 80
         */
        expectedEntries?: number;
        /**
         * Estimated number of subscriptions in PartialSync consumer.
         * @default 16
         */
        expectedSubscriptions?: number;
        /**
         * Whether to use zlib compression on IBLT.
         * Default is no compression. Use `PSyncZlib` to set zlib compression.
         *
         * In PSync C++ library, default for FullSync depends on whether zlib is available at compile
         * time, and default for PartialSync is no compression.
         * This must be set to match other peers.
         */
        ibltCompression?: PSyncCodec.Compression;
        /**
         * Whether to use zlib compression on Data payload.
         * Default is no compression. Use `PSyncZlib` to set zlib compression.
         *
         * In PSync C++ library, default for FullSync depends on whether zlib is available at compile
         * time. For PartialSync, it is always no compression.
         * This must be set to match other peers.
         */
        contentCompression?: PSyncCodec.Compression;
    }
}

/** Use zlib compression with PSync. */
export const PSyncZlib: PSyncCodec.Compression;

export class SyncpsCodec {
    protected readonly ibltParams: IBLT.PreparedParameters;
    constructor(p: SyncpsCodec.Parameters, ibltParams: IBLT.PreparedParameters);
}
interface SyncpsCodec extends Readonly<SyncpsCodec.Parameters>, IbltCodec {
}
export namespace SyncpsCodec {
    type Compression = Compression;
    interface Parameters {
        /** Compression method for IBLT in name component. */
        ibltCompression: Compression;
        /** Compute the hash of a publication. */
        hashPub: (pub: Data) => number;
        /** Encode Content to buffer. */
        encodeContent: (pubs: readonly Data[], maxSize: number) => [wire: Uint8Array, count: number];
        /** Decode Content from buffer. */
        decodeContent: (payload: Uint8Array) => Data[];
    }
}

interface DebugEntry {
    action: string;
    key?: number;
    name?: Name;
    ownIblt: IBLT;
    recvIblt?: IBLT;
    content?: Name[];
}
interface Events {
    debug: (entry: DebugEntry) => void;
}
export const SyncpsPubsub_base: new () => TypedEventEmitter<Events>;
/** syncps - pubsub service. */
export class SyncpsPubsub extends SyncpsPubsub_base implements Subscriber<Name, Data> {
    constructor({ p, endpoint, describe, syncPrefix, addSyncPrefixOnUplinks, syncInterestLifetime, syncDataPubSize, syncSigner, syncVerifier, maxPubLifetime, maxClockSkew, modifyPublication, isExpired, filterPubs, pubSigner, pubVerifier, }: SyncpsPubsub.Options);
    private readonly endpoint;
    readonly describe: string;
    private readonly syncPrefix;
    private readonly codec;
    private readonly uplinkRouteMirror?;
    private closed;
    private readonly iblt;
    private readonly pubs;
    private readonly maxPubLifetime;
    private readonly maxClockSkew;
    private readonly subs;
    private readonly dModify;
    private readonly dIsExpired;
    private readonly dSigner;
    private readonly dVerifier?;
    private nOwnPubs;
    /** IBLT of own publications with callback. */
    private readonly dConfirmIblt;
    private readonly pProducer;
    private readonly pFilter;
    private readonly pPubSize;
    private readonly pPendings;
    private readonly cVerifier?;
    private readonly cLifetime;
    private cAbort?;
    private cTimer;
    private cCurrentInterestNonce?;
    private cDelivering;
    private debug;
    /** Stop the protocol operation. */
    close(): void;
    /**
     * Publish a packet.
     * @param pub a Data packet. This does not need to be signed.
     * @param cb a callback to get notified whether publication is confirmed,
     *           i.e. its hash appears in a sync Interest from another participant.
     * @returns a Promise that resolves when the publication is recorded.
     *          It does not mean the publication has reached other participants.
     */
    publish(pub: Data, cb?: SyncpsPubsub.PublishCallback): Promise<void>;
    /**
     * Subscribe to a topic.
     * @param topic a name prefix.
     */
    subscribe(topic: Name): Subscription<Name, Data>;
    private handleSyncInterest;
    private processSyncInterest;
    private processPendingInterests;
    private scheduleSyncInterest;
    private sendSyncInterest;
    private isExpired;
    private addToActive;
    private invokePublishCb;
}
export namespace SyncpsPubsub {
    interface Parameters extends SyncpsCodec.Parameters {
        iblt: IBLT.Parameters;
    }
    type ModifyPublicationCallback = (pub: Data) => void;
    /**
     * Callback to determine if a publication is expired.
     *
     * The callback can return either:
     * - boolean to indicate whether the publication is expired.
     * - number, interpreted as Unix timestamp (milliseconds) of publication creation time.
     *   The publication is considered expired if this timestamp is before
     *   `NOW - (maxPubLifetime+maxClockSkew)` or after `NOW + maxClockSkew`.
     */
    type IsExpiredCallback = (pub: Data) => boolean | number;
    interface FilterPubItem {
        /** A publication, i.e. Data packet. */
        readonly pub: Data;
        /** Whether the publication is owned by the local participant. */
        readonly own: boolean;
    }
    /**
     * Callback to decide what publications to be included in a response.
     * Argument contains unexpired publications only.
     * It should return a priority list of publications to be included in the response.
     */
    type FilterPubsCallback = (items: FilterPubItem[]) => FilterPubItem[];
    interface Options {
        /**
         * Algorithm parameters.
         * They must be the same on every peer.
         */
        p: Parameters;
        /** Endpoint for communication. */
        endpoint?: Endpoint;
        /** Description for debugging purpose. */
        describe?: string;
        /** Sync group prefix. */
        syncPrefix: Name;
        /**
         * Whether to automatically add sync group prefix as a route on uplinks.
         * @default true
         */
        addSyncPrefixOnUplinks?: boolean;
        /**
         * Sync Interest lifetime in milliseconds.
         * @default 4000
         */
        syncInterestLifetime?: number;
        /**
         * Advisory maximum size for publications included in a sync reply Data packet.
         * @default 1300
         */
        syncDataPubSize?: number;
        /**
         * Signer of sync reply Data packets.
         * Default is digest signing.
         */
        syncSigner?: Signer;
        /**
         * Verifier of sync reply Data packets.
         * Default is no verification.
         */
        syncVerifier?: Verifier;
        /**
         * Publication lifetime.
         * @default 1000
         */
        maxPubLifetime?: number;
        /**
         * Maximum clock skew, for calculating timers.
         * @default 1000
         */
        maxClockSkew?: number;
        /**
         * Callback to modify publication before it's signed.
         * Default is appending a TimestampNameComponent to the name.
         */
        modifyPublication?: ModifyPublicationCallback;
        /**
         * Callback to determine if a publication is expired.
         * Default is interpreting the last component as TimestampNameComponent;
         * if the last component is not a TimestampNameComponent, it is seen as expired.
         */
        isExpired?: IsExpiredCallback;
        /**
         * Callback to decide what publications to be included in a response.
         * Default is: respond nothing if there's no own publication; otherwise,
         * prioritize own publications over others, and prioritize later timestamp.
         */
        filterPubs?: FilterPubsCallback;
        /**
         * Signer of publications.
         * Default is digest signing.
         */
        pubSigner?: Signer;
        /**
         * Verifier of publications.
         * Default is no verification.
         */
        pubVerifier?: Verifier;
    }
    type PublishCallback = (pub: Data, confirmed: boolean) => void;
}

/** Create algorithm parameters to be compatible with PSync C++ library. */
export function makeSyncpsCompatParam({ keyToBufferLittleEndian, expectedEntries, }?: makeSyncpsCompatParam.Options): SyncpsPubsub.Parameters;
export namespace makeSyncpsCompatParam {
    interface Options {
        /**
         * Whether to use little endian when converting a uint32 key to a byte array.
         * ndn-ind behaves differently on big endian and little endian machines,
         * https://github.com/operantnetworks/ndn-ind/blob/dd934a7a5106cda6ea14675554427e12df1ce18f/src/lite/util/crypto-lite.cpp#L114
         * This must be set to match other peers.
         * @default true
         */
        keyToBufferLittleEndian?: boolean;
        /**
         * Expected number of IBLT entries, i.e. expected number of updates in a sync cycle.
         * @default 85
         */
        expectedEntries?: number;
    }
}

export const sync_IBLT: typeof IBLT;
export const sync_makePSyncCompatParam: typeof makePSyncCompatParam;
export const sync_PSyncFull: typeof PSyncFull;
export const sync_PSyncZlib: typeof PSyncZlib;
export const sync_PSyncPartialPublisher: typeof PSyncPartialPublisher;
export const sync_PSyncPartialSubscriber: typeof PSyncPartialSubscriber;
export const sync_makeSyncpsCompatParam: typeof makeSyncpsCompatParam;
export const sync_SyncpsPubsub: typeof SyncpsPubsub;
export const sync_SyncProtocol: typeof SyncProtocol;
type sync_SyncNode<_0> = SyncNode<_0>;
type sync_SyncUpdate<_0> = SyncUpdate<_0>;
export const sync_SyncUpdate: typeof SyncUpdate;
type sync_Subscriber<_0, _1, _2> = Subscriber<_0, _1, _2>;
export const sync_Subscription: typeof Subscription;
export namespace sync {
  export {
    sync_IBLT as IBLT,
    sync_makePSyncCompatParam as makePSyncCompatParam,
    sync_PSyncFull as PSyncFull,
    sync_PSyncZlib as PSyncZlib,
    sync_PSyncPartialPublisher as PSyncPartialPublisher,
    sync_PSyncPartialSubscriber as PSyncPartialSubscriber,
    sync_makeSyncpsCompatParam as makeSyncpsCompatParam,
    sync_SyncpsPubsub as SyncpsPubsub,
    sync_SyncProtocol as SyncProtocol,
    sync_SyncNode as SyncNode,
    sync_SyncUpdate as SyncUpdate,
    sync_Subscriber as Subscriber,
    sync_Subscription as Subscription,
  };
}

export const node: INode;
export const ndn: {
    packet: typeof packet;
    tlv: typeof tlv;
    sync: typeof sync;
};

}


const node = t.node;


const ndn = t.ndn;


declare function visualize(packet: any): void;


